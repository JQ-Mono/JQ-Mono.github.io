<!DOCTYPE html>
<html>
<meta  lang="zh_CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <link rel="icon" href="/img/img.jpg">
  <title>Monologue's blog</title>
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  <link rel="prefetch" href="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js" as="script">
  
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
  
  
  
  <link href="/js/lib/prism/prism.min.css" rel="stylesheet" data-prism="prism">
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/img.jpg">
      
      <span class="navbar-logo-dsc">Monologue's blog</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">首页 </a>
    
    <a href="/archives" class="navbar-menu-item">归档 </a>
    
    <a href="/tags" class="navbar-menu-item">标签 </a>
    
    <a href="/categories" class="navbar-menu-item">分类 </a>
    
    <a href="/about" class="navbar-menu-item">关于 </a>
    
    <a href="/links" class="navbar-menu-item">友链 </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
  </div>
</nav>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      经典基础算法
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2020-10-09T16:00:00.000Z" style="display: flex; align-items: center;">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2020-10-10</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/算法/" class="post-meta-link">算法</a>
    
    
    
    <span class="dot"></span>
    <span>12.3k 字</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/算法/" class="post-meta-link">算法</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h2 id="一、动态规划"><a href="#一、动态规划" class="headerlink" title="一、动态规划"></a>一、动态规划</h2><h3 id="1、背包问题"><a href="#1、背包问题" class="headerlink" title="1、背包问题"></a>1、背包问题</h3><h4 id="lt-01背包-gt"><a href="#lt-01背包-gt" class="headerlink" title="&lt;01背包&gt;"></a>&lt;01背包&gt;</h4><ul>
<li><font size=4 color=blue>N个物品，物品i具有体积vi、价值pi，现有一容量为V的背包，问背包能装的物品的价值的最大值</font></li>
<li><font size=4 color=red>若定义一个二维数组dp[i][j]，表示前i个物品在只提供j容量大小时物品的最大值。</font><ul>
<li>递推式：<font size=4>dp[i][j] = max { dp[i - 1][j] , dp[i – 1][j – weight[i]] + val[i] }</font></li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(int j &#x3D; 0; j &lt;&#x3D; V; ++j) &#x2F;&#x2F; 初始化，拿0个物品的价值为0
    dp[0][j] &#x3D; 0;
for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)
    for (int j &#x3D; 0; j &lt;&#x3D; V; ++j)
        if (j &lt; weight[i])
            dp[i][j] &#x3D; dp[i - 1][j];
		else
            dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + val[i]);</code></pre>

<ul>
<li><font size=4 color=red><strong>二维数组中用下一行的话之前的几行就没有用了！</strong>所以，为了节省内存，我们用一维数组来维护每一行的数据，并更新。（滚动数组）</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">memset(dp, 0, sizeof dp);
for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)
    for(int j &#x3D; V; j &gt;&#x3D; weight[i]; --j)
        dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + val[i]);</code></pre>

<ul>
<li>举例：n=4、(weight , val) = {(2 , 3) , (1 , 2) , (3 , 4) , (2 , 2)}、V=5</li>
</ul>
<table>
<thead>
<tr>
<th align="center">i\j</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
</tr>
</tbody></table>
<ul>
<li><p>dp[3][4] = max(dp[2][4] , dp[2][1] + 4) 、dp[3][1] = max(dp[3][1] , dp[2][1])</p>
</li>
<li><p><font size=4 color=red>若要求恰s好放满背包：</font></p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define INF -2e9
dp[0][0] &#x3D; 0;
for(int j &#x3D; 1; j &lt;&#x3D; V; ++j) &#x2F;&#x2F; 初始化拿0个物品的价值为0
    dp[0][j] &#x3D; INF; &#x2F;&#x2F; ？？？
&#x2F;&#x2F;空间优化后
dp[0] &#x3D; 0;
for(int i &#x3D; 1; i &lt;&#x3D; V; ++i)
    dp[i] &#x3D; INF;</code></pre>

<h4 id="lt-完全背包-gt"><a href="#lt-完全背包-gt" class="headerlink" title="&lt;完全背包&gt;"></a>&lt;完全背包&gt;</h4><ul>
<li><font size=4 color=blue>上述问题中物品数量改为无穷个，即为完全背包问题</font></li>
</ul>
<h3 id="2、字符串距离"><a href="#2、字符串距离" class="headerlink" title="2、字符串距离"></a>2、字符串距离</h3><ul>
<li><font size = 4>状态转移表达式如下：</font></li>
</ul>
<p>$$<br>Lev_{a,b}(i,j)=<br>\begin{cases}<br>i&amp;,j=0 \<br>j&amp;,i=0 \<br>min<br>\begin{cases}<br>Lev_{a,b}(i,j-1)+1\<br>Lev_{a,b}(i-1,j)+1\<br>Lev_{a,b}(i-1,j-1)+1<br>\end{cases}<br>&amp;, other<br>\end{cases}<br>$$</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 时间复杂度为O(MN)，空间复杂度为O(MN)
int getDistence(string a, string b)&#123; &#x2F;&#x2F; 计算字符串a、b的距离
    int dp[M][M]; &#x2F;&#x2F; dp[i][j]表示a的前i个字符与b的前j个字符，两字符串的距离
    int alen &#x3D; a.size(), blen &#x3D; b.size();
    clr(dp);
    for(int i &#x3D; 1; i &lt;&#x3D; alen; ++i)&#123; &#x2F;&#x2F; 初始化边界
        dp[i][0]&#x3D;i;
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; blen; ++i)&#123; &#x2F;&#x2F; 初始化边界
        dp[0][i]&#x3D;i;
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; alen; ++i)&#123;
        for(int j &#x3D; 1; j &lt;&#x3D; blen; ++j)&#123;
            if(a[i-1] &#x3D;&#x3D; b[j-1])
                dp[i][j] &#x3D; dp[i-1][j-1];
            else
                dp[i][j] &#x3D; min(dp[i][j-1], min(dp[i-1][j-1], dp[i-1][j])) + 1;
        &#125;
    &#125;
    return dp[alen][blen];
&#125;
&#x2F;&#x2F; 可用一维滚动数组将空间复杂度降为O(max&#123;M,N&#125;)（以下摘自网络，尚未分析）
int dp[1010];
void work() &#123;
	for(int j&#x3D;1; j&lt;&#x3D;lenb; j++) dp[j] &#x3D; j;
	int t1, t2;
	for(int i&#x3D;1; i&lt;&#x3D;lena; i++) &#123;
		t1 &#x3D; dp[0]++;
		for(int j&#x3D;1; j&lt;&#x3D;lenb; j++) &#123;
			t2 &#x3D; dp[j];
			if(a[i-1]&#x3D;&#x3D;b[j-1])
                dp[j] &#x3D; t1;
            else
                dp[j] &#x3D; min(t1, min(dp[j-1], dp[j]))+1;
            t1 &#x3D; t2;
        &#125;
    &#125;
    printf(&quot;%d\n&quot;, dp[lenb]);
&#125;</code></pre>

<h3 id="3、求最大连续子序列和"><a href="#3、求最大连续子序列和" class="headerlink" title="3、求最大连续子序列和"></a>3、求最大连续子序列和</h3><ul>
<li><font size = 4 color = blue>状态转移方程：sum[i] = max{sum[i-1]+a[i],a[i]}</font></li>
<li><font size = 4 color = blue>sum[i]记录以a[i]为子序列末端的最大连续子序列和</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">int MaxSum(int n)&#123;
    int sum &#x3D; 0,b &#x3D; 0;
    for(int i &#x3D; 0; i &lt; n; i++)&#123;
        if(b &gt; 0) b +&#x3D; a[i];
        else b &#x3D; a[i];
        if(b &gt; sum) sum &#x3D; b;
    &#125;
    return sum;
&#125;</code></pre>



<h2 id="二、图论"><a href="#二、图论" class="headerlink" title="二、图论"></a>二、图论</h2><h3 id="1、图的表示"><a href="#1、图的表示" class="headerlink" title="1、图的表示"></a>1、图的表示</h3><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;* 邻接矩阵：g[i][j]表示编号i的点到编号j的点这段路的权值 *&#x2F;
&#x2F;* 对于无权图，可以将矩阵定义为bool类型，判断两点之间是否有边 *&#x2F;
&#x2F;* 对于有权图，可以令不直接相连的两点i、j：g[i][j]&#x3D;INF，区分于权值为0的边 *&#x2F;
#define INF 0x3fffffff
#define M 1010
bool g1[M][M];
int g2[M][M];
&#x2F;* 邻接表,定义不再赘述 *&#x2F;
#include&lt;vector&gt;
vector&lt;int&gt; g[M];
int main()&#123;
    int n,m; &#x2F;&#x2F; n个点，m条边
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 0; i &lt; m; ++i)&#123;
        int s,t;
        cin&gt;&gt;s&gt;&gt;t;
        g[s].push_back(t);
    &#125;
    &#x2F;* 图的操作 *&#x2F;
    return 0;
&#125;
&#x2F;* 边上有属性的情况 *&#x2F;
class edge&#123;
public:
    edge(int e,int l):end(e),len(l)&#123;&#125;
    int end;
    int len;
&#125;;
&#x2F;&#x2F; typedef pair&lt;int,int&gt; edge; first是最短距离，second是终顶点的编号
vector&lt;edge&gt; g[M];</code></pre>

<h3 id="2、单源最短路问题——Dijkstra算法"><a href="#2、单源最短路问题——Dijkstra算法" class="headerlink" title="2、单源最短路问题——Dijkstra算法"></a>2、单源最短路问题——Dijkstra算法</h3><ul>
<li><p><font size=4 color=red>每轮松弛后在dis数组（保存着每个点到源点的最短距离）中挑出未标记的最小值，并标记这个点，再将这个点作为新一轮松弛的起点，直至所有点都被标记</font></p>
</li>
<li><p><font size=4 color=blue>邻接矩阵，复杂度为O(n^2^)</font></p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define INF 0x7fffffff
#define M 1010
int map[M][M],dis[M]; &#x2F;&#x2F; map保存图，dis保存源点到其他每个点的最短距离
int n,e,start,end;
bool flag[M];
void dijkstra(int s)&#123; &#x2F;&#x2F; s为源点
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;
        &#x2F;* 初始化：每个点均未被确认答案，每个点到源点距离为无穷大 *&#x2F;
		flag[i]&#x3D;true;
		dis[i]&#x3D;INF;
	&#125;
    &#x2F;* 初始松弛，修改与源点有边的点的最短距离 *&#x2F;
	flag[s] &#x3D; false;
	for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)
		if(dis[i] &gt; map[s][i])
			dis[i] &#x3D; map[s][i];
    &#x2F;* 剩下n-1轮松弛，每次从dis中挑出最小且未确定的点，对其他所有点进行松弛 *&#x2F;
	for(int i &#x3D; 1; i &lt; n; ++i)&#123;
		int bestPoint,min&#x3D;INF;
		for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)
			if(flag[j] &amp;&amp; dis[j] &lt; min)
				min &#x3D; dis[j];
				bestPoint &#x3D; j;
			&#125;
		&#125;
		flag[bestPoint]&#x3D;false; &#x2F;&#x2F; 标记已访问的点
		for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)
			if(dis[j] &gt; dis[bestPoint]+map[bestPoint][j])
				dis[j] &#x3D; dis[bestPoint]+map[bestPoint][j];
	&#125;
&#125;</code></pre>

<ul>
<li><font size=4 color=blue>邻接表，用优先队列能以O(logn)复杂度选取每轮的最短距离，优化到O(Mlogn)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#define M 200010
#define INF 0x7fffffff
using namespace std;
class edge&#123;
public:
    edge(int e,int l):end(e),len(l)&#123;&#125;
    int end;
    int len;
&#125;;
bool operator &gt; (const edge&amp; e1,const edge&amp; e2)&#123;
	return e1.len &gt; e2.len; &#x2F;&#x2F; 用于优先队列中的比较
&#125;
int n,m,dis[M];
vector&lt;edge&gt; g[M]; &#x2F;&#x2F; 图的保存

void dijkstra(int s)&#123;
	priority_queue&lt;edge, vector&lt;edge&gt;, greater&lt;edge&gt; &gt; q;
	for(int i &#x3D; 0; i &lt;&#x3D; n; ++i) dis[i]&#x3D;INF; &#x2F;&#x2F; 初始化到源点最短距离
	dis[s] &#x3D; 0; &#x2F;&#x2F; 源点到源点距离为0
	q.push(edge(s,0)); &#x2F;&#x2F; 优先队列中初始化一个源点
	while(q.size())&#123;
		edge e &#x3D; q.top();
		q.pop();
		int newStart &#x3D; e.end;
		if(dis[newStart] &lt; e.len) continue; &#x2F;&#x2F; 相当于删掉已经被松弛却还没从优先队列中删掉的边
		for(int i &#x3D; 0; i &lt; g[newStart].size(); ++i)&#123;
			edge evEdge &#x3D; g[newStart][i]; &#x2F;&#x2F; 枚举每个从newStart开始的边
            &#x2F;* 判断是否可以松弛，可以的话就把松弛后的边加入优先队列 *&#x2F;
			if(dis[evEdge.end] &gt; dis[newStart] + evEdge.len)&#123;
				dis[evEdge.end] &#x3D; dis[newStart] + evEdge.len;
				q.push( edge(evEdge.end,dis[evEdge.end]) );
			&#125;
		&#125;
	&#125;
&#125;
&#x2F;* 使用实例：输入顶点数、边数、源点编号，以及每条边的属性，按顺序输出每个点到源点的最短距离 *&#x2F;
int main()&#123;
	int s;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i&#x3D;0;i&lt;m;++i)&#123;
		int start,end,len;
		cin&gt;&gt;start&gt;&gt;end&gt;&gt;len;
		g[start].push_back(edge(end,len));
	&#125;
	dijkstra(s);
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)cout&lt;&lt;dis[i]&lt;&lt;&#39; &#39;;
	return 0;
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 2020.11.13 重写
#include&lt;bits&#x2F;stdc++.h&gt;
#define M 200010
#define INF 0x7fffffff
using namespace std;

int n,m,dis[M];
vector&lt;pair&lt;int, int&gt;&gt; g[M]; &#x2F;&#x2F; 图的保存

void dijkstra(int s)&#123;
	priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q;
	for(int i &#x3D; 0; i &lt;&#x3D; n; ++i) dis[i] &#x3D; INF; &#x2F;&#x2F; 初始化到源点最短距离
	dis[s] &#x3D; 0; &#x2F;&#x2F; 源点到源点距离为0
	q.push(&#123;0, s&#125;); &#x2F;&#x2F; 优先队列中初始化一个源点
	while(q.size())&#123;
		auto e &#x3D; q.top(); q.pop();
		int ns &#x3D; e.second;
		if(dis[ns] &lt; e.first) continue; &#x2F;&#x2F; 删掉已经被松弛却还没从优先队列中删掉的边
		for(int i &#x3D; 0; i &lt; g[ns].size(); ++i)&#123;
			auto ev &#x3D; g[ns][i]; &#x2F;&#x2F; 枚举每个从newStart开始的边
            &#x2F;* 判断是否可以松弛，可以的话就把松弛后的边加入优先队列 *&#x2F;
			if(dis[ev.second] &gt; dis[ns] + ev.first)&#123;
				dis[ev.second] &#x3D; dis[ns] + ev.first;
				q.push(&#123;dis[ev.second], ev.second&#125;);
			&#125;
		&#125;
	&#125;
&#125;
int main()&#123;
	int s;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i &#x3D; 0; i &lt; m; ++i)&#123;
		int start,end,len;
		cin&gt;&gt;start&gt;&gt;end&gt;&gt;len;
		g[start].push_back(&#123;len, end&#125;);
	&#125;
	dijkstra(s);
	for(int i &#x3D; 1; i &lt;&#x3D; n; ++i) cout&lt;&lt;dis[i]&lt;&lt;&#39; &#39;;
	return 0;
&#125;</code></pre>



<h3 id="3、单源最短路问题——Bellman-Ford算法"><a href="#3、单源最短路问题——Bellman-Ford算法" class="headerlink" title="3、单源最短路问题——Bellman-Ford算法"></a>3、单源最短路问题——Bellman-Ford算法</h3><ul>
<li><font size=4 color=blue>Bellman-Ford算法的时间复杂度是O(MN)，高于Dijkstra算法，但是可以处理存在负边的情况</font></li>
<li><font size=4>使用队列优化可以稍微降低其复杂度，而且队列优化后的算法还有个另外的名字：SPFA（Shortest Path Faster Algorithm），可以比较好的适用于随机图。但是一旦数据有特殊，可以将这个算法卡回O(MN)，有时会导致超时。</font></li>
<li><font size=4>因此在没有负权的情况下还是用Dijkstra算法好一些</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define M 200010
#define INF 0x7fffffff
class edge&#123;
public:
    edge(int s,int e,int l):start(s),end(e),len(l)&#123;&#125;
    int start;
    int end;
    int len;
&#125;;
int n,m,dis[M]; &#x2F;&#x2F; n个点，m条边，dis保存最短距离
edge edges[Max_E]; &#x2F;&#x2F; 保存所有的边
&#x2F;* 算法可以判断图中是否有负环，如需做此判断，需要进行n次循环才行 *&#x2F;
bool Bellman-Ford(int s)&#123;
    for(int i &#x3D; 0; i &lt; n; ++i)dis[i] &#x3D; INF;
    dis[s] &#x3D; 0;
    for(int i &#x3D; 0; i &lt; n; ++i)&#123;
        for(int j &#x3D; 0; j &lt; m; ++j)&#123;
            edge evEdge &#x3D; edges[j];
            if(dis[evEdge.end] &gt; dis[evEdge.start] + evEdge.len)&#123;
                dis[evEdge.end] &#x3D; dis[evEdge.start] + evEdge.len;
                if(i &#x3D;&#x3D; n-1) return false; &#x2F;&#x2F; 若第n轮仍有松弛，则存在负环
            &#125;
        &#125;
    &#125;
    return true;
&#125;
&#x2F;* 如果不用判断是否有负环，则无需进行n-1次循环，可以稍加优化时间效率 *&#x2F;
void Bellman-Ford(int s)&#123;
    for(int i &#x3D; 0; i &lt; n; ++i)dis[i] &#x3D; INF;
    dis[s] &#x3D; 0;
    while(true)&#123;
        bool update &#x3D; false; &#x2F;&#x2F; 循环至不再更新就可以停下
        for(int i &#x3D; 0; i &lt; m; ++i)&#123;
            edge evEdge &#x3D; edges[i];
            if(dis[evEdge.start] &#x3D;&#x3D; INF) continue; &#x2F;&#x2F; 还未松弛到某边的起点时，暂时略过
            if(dis[evEdge.end] &gt; dis[evEdge.start]+evEdge.len)&#123;
                dis[evEdge.end] &#x3D; dis[evEdge.start]+evEdge.len;
                update &#x3D; true;
            &#125;
        &#125;
        if(!update) break;
    &#125;
&#125;
&#x2F;* 若图是不存在环的，那么可以按拓扑序给顶点编号，按序松弛，此时效率最优 *&#x2F;</code></pre>



<h3 id="4、多源最短路问题——Floyd-Warshall算法"><a href="#4、多源最短路问题——Floyd-Warshall算法" class="headerlink" title="4、多源最短路问题——Floyd-Warshall算法"></a>4、多源最短路问题——Floyd-Warshall算法</h3><ul>
<li><font size=4 color=blue>用于解决多源最短路径问题的算法</font></li>
<li><font size=4 color=blue>时间复杂度为O（n^3^）</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;Floyd算法（关键部分）
&#x2F;&#x2F;e[i][j]表示由i到j的路径长度
for(int k &#x3D; 0; k &lt; n; ++k)&#123;
	for(int i &#x3D; 0; i &lt; n; ++i)
		for(int j &#x3D; 0; j &lt; n; ++j)
			if(map[i][j] &gt; map[i][k] + map[k][j])
				map[i][j] &#x3D; map[i][k] + map[k][j];
&#125;
&#x2F;* 也可以判断是否有负环，但是有些大材小用 *&#x2F;
for(int i&#x3D;0;i&lt;n;++i)
    if(map[i][i] &lt; 0)
        flag &#x3D; false; &#x2F;&#x2F; 表示出现了负环
	&#125;
&#125;</code></pre>



<h3 id="5、最短路径还原"><a href="#5、最短路径还原" class="headerlink" title="5、最短路径还原"></a>5、最短路径还原</h3><ul>
<li><font size=4>该方法适用于以上最短路算法</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">int prev[M]; &#x2F;&#x2F; prev[i]表示最短路上顶点i的前驱，用于路径还原
&#x2F;* 在每次松弛的时候更新prev数组即可 *&#x2F;
&#x2F;* 还原时，不断把j替换成prev[j]直到j&#x3D;s为止 *&#x2F;</code></pre>



<h3 id="6、最小生成树——Prim算法"><a href="#6、最小生成树——Prim算法" class="headerlink" title="6、最小生成树——Prim算法"></a>6、最小生成树——Prim算法</h3><ul>
<li><font size=4 color=blue>假设一颗只包含一个顶点v的树T。然后贪心地选取T和其他顶点之间相连的最小权值的边，并把它加到T中。处理过程与Dijkstra算法相似</font></li>
<li><font size=4>在不优化的情况下，时间复杂度是O(N^2^)，代码写起来也稍微复杂些</font></li>
<li><del>（真不知道这个算法的意义在哪）</del></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">int cost[M][M]; &#x2F;&#x2F; cost[i][j]表示边(i,j)的权值，不存在的情况下设为INF
int mincost[M]; &#x2F;&#x2F; 从集合T出发到每个顶点的最小权值
bool used[M]; &#x2F;&#x2F; 顶点i是否包含在集合T中
int n;
int prim()&#123;
    for(int i &#x3D; 0; i &lt; n; ++i)&#123;
        mincost[i] &#x3D; INF;
        used[i] &#x3D; false;
    &#125;
    mincost[0] &#x3D; 0; &#x2F;&#x2F; 默认T初始化为只有编号为0这一个顶点
    int ans &#x3D; 0; &#x2F;&#x2F; 最小生成树的总权值
    while(true)&#123;
        int v &#x3D; -1; &#x2F;&#x2F; 挑出在集合T外、T到其权值最小的顶点
        for(int i &#x3D; 0; i &lt; n; ++i)
            if(!used[i] &amp;&amp; (v &#x3D;&#x3D; -1 || mincost[i] &lt; mincost[v])) v &#x3D; i;
        if(v &#x3D;&#x3D; -1) break; &#x2F;&#x2F; 所有点都已经被加入T集合
        used[v] &#x3D; true; &#x2F;&#x2F; 加入T集合
        ans +&#x3D; mincost[v];
        for(int i &#x3D; 0; i &lt; n; ++i)&#123;
            mincost[i] &#x3D; min(mincost[i],cost[v][i]); &#x2F;&#x2F; 用新加入的点松弛其他所有点
        &#125;
    &#125;
    return ans;
&#125;</code></pre>



<h3 id="7、最小生成树——Kruskal算法"><a href="#7、最小生成树——Kruskal算法" class="headerlink" title="7、最小生成树——Kruskal算法"></a>7、最小生成树——Kruskal算法</h3><ul>
<li><font size=4 color=blue>对边从小到大排序，用并查集维护连通分量，依次添加权值最小且不在同一个连通分量的边</font></li>
<li><font size=4>时间复杂度是O(MlogN)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define M 200010
class edge&#123;
public:
    edge(int s,int e,int l):start(s),end(e),len(l)&#123;&#125;
    int start;
    int end;
    int len;
&#125;;
bool cmp(const edge&amp; e1,const edge&amp; e2)&#123;
    return e1.len &lt; e2.len;
&#125;
int f[M]; &#x2F;&#x2F; 并查集
edge edges[M]; &#x2F;&#x2F; 边集
int n,m;
int find(int x)&#123;return f[x]&#x3D;&#x3D;x?x:f[x]&#x3D;find(f[x]);&#125;
int Kruskal()&#123;
    sort(edges,edges+m,cmp);
    for(int i &#x3D; 0; i &lt;&#x3D; n; ++i) f[i] &#x3D; i; &#x2F;&#x2F; 初始化并查集
    int ans &#x3D; 0;
    for(int i &#x3D; 0; i &lt; m; ++i)&#123;
        edge evEdge &#x3D; edges[i];
        if(find(evEdge.start) !&#x3D; find(evEdge.end))&#123;
            ans +&#x3D; evEdge.len;
            f[find(evEdge.start)] &#x3D; find(evEdge.end); &#x2F;&#x2F; 合并两分量
        &#125;
    &#125;
    return ans;
&#125;
&#x2F;&#x2F; 或堆排序维护优先队列（课设D2题）</code></pre>



<h3 id="8、强连通分量——Tarjan算法"><a href="#8、强连通分量——Tarjan算法" class="headerlink" title="8、强连通分量——Tarjan算法"></a>8、强连通分量——Tarjan算法</h3><ul>
<li><font size=4 color=blue>时间复杂度为O(N+M)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#define M 10010
using namespace std;
int dfn[M],low[M]; &#x2F;&#x2F; dfn保存每个点的时间戳编号，low是某个点或其子树能够追溯到最早的栈中结点编号
int Bcnt,index,stack[M],top; &#x2F;&#x2F; Bcnt记录强连通分量个数，index是时间戳，top是栈顶编号
bool instack[M]; &#x2F;&#x2F; 判断某个点是否在栈内
vector&lt;int&gt; g[M]; &#x2F;&#x2F; 邻接表保存图
void tarjan(int i)&#123;
	int j;
	dfn[i] &#x3D; low[i] &#x3D; ++index; &#x2F;&#x2F; dfn、low初始化为时间戳
	instack[i] &#x3D; true; &#x2F;&#x2F; i入栈，作为一颗（子）dfs树的根
	stack[++top] &#x3D; i;
	for(int k &#x3D; 0; k &lt; g[i].size(); ++k)&#123; &#x2F;&#x2F; 访问以i为起点的所有边
		j &#x3D; g[i][k]; &#x2F;&#x2F; j记录以i为起点的某条边的终点
		if(!dfn[j])&#123; &#x2F;&#x2F; 若这个点还没被访问，就递归调用函数，压栈
			tarjan(j);
			if(low[j] &lt; low[i]) low[i] &#x3D; low[j]; &#x2F;&#x2F; 若j的根被放小，则把j的根i也放小
		&#125;
        &#x2F;* 或者j这个点已被访问但是j在栈中，且j的时间戳早于i，将i的low放小 *&#x2F;
		else if(instack[j] &amp;&amp; dfn[j] &lt; low[i]) low[i] &#x3D; dfn[j];
	&#125;
	if(dfn[i] &#x3D;&#x3D; low[i])&#123; &#x2F;&#x2F; i这个点未被放小，则以i为根的一颗dfs子树是一个强连通分量
		Bcnt++;
        &#x2F;* 弹栈至i被弹出 *&#x2F;
		do&#123;
			j &#x3D; stack[top--];
			instack[j] &#x3D; false;
		&#125;while(j !&#x3D; i);
	&#125;
&#125;
&#x2F;* 使用样例：输入点、边数和所有边，输出强连通分量个数 *&#x2F;
int main()
&#123;
	int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 0; i &lt; m; ++i)&#123;
        int s,t;
        cin&gt;&gt;s&gt;&gt;t;
        g[s].push_back(t);
    &#125;
    for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;
    	if(!dfn[i])tarjan(i);
	&#125;
	cout&lt;&lt;Bcnt;
	return 0;
&#125;</code></pre>



<h3 id="9、最近公共祖先问题——LCA（Lowest-Common-Ancestor）"><a href="#9、最近公共祖先问题——LCA（Lowest-Common-Ancestor）" class="headerlink" title="9、最近公共祖先问题——LCA（Lowest Common Ancestor）"></a>9、最近公共祖先问题——LCA（Lowest Common Ancestor）</h3><ul>
<li><font size=4 color=blue>朴素做法是，让两个点（若不在同一层，先爬到同一层）一起往上爬，直至相遇。利用倍增提高效率，每次向上爬的高度不是1，而是2的幂</font></li>
<li><font size=4 color=blue>用f[i][j]表示从结点i向上爬2^j^的高度所到达的结点，则f[i][0]就表示结点i的父结点</font></li>
<li><font size=4>顶点编号从1开始</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#define N 500010 &#x2F;&#x2F; 顶点个数
#define LogN 20
using namespace std;
vector&lt;int&gt; g[N];
int f[N][LogN];
int dep[N],lg[N]; &#x2F;&#x2F; lg预处理log_2(n)的值
int n,m,root;
void dfs(int x,int p,int d)&#123; &#x2F;&#x2F;当前点的编号为x，深度为d，其父结点编号为p（-1表示无父结点）
	f[x][0] &#x3D; p; &#x2F;&#x2F; 向上爬1层是父结点
	dep[x] &#x3D; d; &#x2F;&#x2F; 记录深度
	for(int i &#x3D; 0; i &lt; g[x].size(); ++i)&#123;
        &#x2F;* 在判断不是自环的情况下，递归记录更深的结点 *&#x2F;
		if(g[x][i] !&#x3D; p) dfs(g[x][i], x, d+1);
	&#125;
&#125;
void init()&#123; &#x2F;&#x2F; 预处理函数，包括所有必要的处理
	dfs(root,-1,0); &#x2F;&#x2F; 
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)
		lg[i] &#x3D; lg[i-1] + (1 &lt;&lt; lg[i-1]+1 &#x3D;&#x3D; i); &#x2F;&#x2F; 预处理log_2(n)的值
	for(int k &#x3D; 0; k+1 &lt; LogN; ++k)&#123;
		for(int x &#x3D; 1; x &lt;&#x3D; n; ++x)&#123;
			if(f[x][k] &lt; 0) f[x][k+1] &#x3D; -1; &#x2F;&#x2F; 爬2的k次幂已经超过根了，那么k+1次幂也超过了
			else f[x][k+1] &#x3D; f[f[x][k]][k]; &#x2F;&#x2F; 爬2的k+1次幂相当于爬两次k次幂
		&#125;
	&#125;
&#125; 
int LCA(int x,int y)&#123;
	if(dep[x] &lt; dep[y]) x^&#x3D;y^&#x3D;x^&#x3D;y; &#x2F;&#x2F; 交换x、y，使得x的深度更深
	while(dep[x] &gt; dep[y]) x &#x3D; f[x][lg[dep[x]-dep[y]]]; &#x2F;&#x2F; x向上爬直至和y同层
	if(x&#x3D;&#x3D;y) return x; &#x2F;&#x2F; 若已经同一层，直接返回
    &#x2F;* 同时往上爬，由大步向小步循环判断，若爬一次两结点相同，暂时认为爬多了 *&#x2F;
	for(int k &#x3D; lg[dep[x]]; k &gt;&#x3D; 0; --k)&#123;
		if(f[x][k] !&#x3D; f[y][k])&#123;
			x &#x3D; f[x][k];
			y &#x3D; f[y][k];
		&#125;
	&#125;
	return f[x][0];
&#125;
&#x2F;* 使用样例 *&#x2F;
int main()&#123;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;root; &#x2F;&#x2F; root是根，LCA是以根节点开始进行dfs的树
	for(int i &#x3D; 0; i &lt; n-1; ++i)&#123; &#x2F;&#x2F; 数据保证为树的话，边数肯定是n-1
        int s,t;
        cin&gt;&gt;s&gt;&gt;t;
        g[s].push_back(t); &#x2F;&#x2F; 注意这是个无向图，dfs确定方向即可
        g[t].push_back(s);
    &#125;
    init(); &#x2F;&#x2F; 预处理
    while(m--)&#123; &#x2F;&#x2F; m次询问
    	int x,y;
    	cin&gt;&gt;x&gt;&gt;y;
    	cout&lt;&lt;LCA(x,y)&lt;&lt;endl;
	&#125;
	return 0;
&#125;</code></pre>



<h2 id="三、高级数据结构"><a href="#三、高级数据结构" class="headerlink" title="三、高级数据结构"></a>三、高级数据结构</h2><h3 id="1、并查集"><a href="#1、并查集" class="headerlink" title="1、并查集"></a>1、并查集</h3><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;带路径压缩：
#define M 100
int f[M]; &#x2F;&#x2F; f[i]表示i的根编号
int find(int x)&#123; &#x2F;&#x2F; 查找根编号
    return f[x] &#x3D;&#x3D; x ? x : f[x] &#x3D; find(f[x]);
&#125;
&#x2F;&#x2F;合并两分量i、j：
f[find(i)] &#x3D; find(j);</code></pre>


<h3 id="2、线段树（segment-Tree）"><a href="#2、线段树（segment-Tree）" class="headerlink" title="2、线段树（segment Tree）"></a>2、线段树（segment Tree）</h3><ul>
<li><blockquote>
<p><font size=4 color=black>经典的例子：从数组a[0…n-1]中查找数组某个区间内的最小值，其中数组大小固定，但是数组中的元素的值可以随时更新。</font></p>
<ul>
<li><font size=4 color=black>解法一：暴力，遍历区间找到最小值。查询时间复杂度O(n)，空间复杂度O(1)</font></li>
<li><font size=4 color=black>解法二：二维数组维护所有子区间。预处理复杂度O(n^2^)，查询时间复杂度O(1)，空间复杂度O(n^2^)</font></li>
<li><font size=4 color=black>解法三：线段树。预处理耗时O(n)，查询、更新操作O(logn)，需要额外空间O(n)</font></li>
</ul>
</blockquote>
</li>
<li><font size=4 color=blue>第一阶段：以维护区间和为例，建立线段树</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">void pushup(int o)&#123;sumv[o]&#x3D;sumv[o&lt;&lt;1]+sumv[o&lt;&lt;1|1];&#125; &#x2F;&#x2F; 向上更新
&#x2F;* 建立线段树 *&#x2F;
void build(int o,int l,int r)&#123; &#x2F;&#x2F; o为当前位置，l为区间左端，r为区间右端
	if(l&#x3D;&#x3D;r)&#123;sumv[o]&#x3D;a[l];return;&#125; &#x2F;&#x2F; 当递归到最后一个位置时，保存区间和sumv
	int mid&#x3D;(l+r)&gt;&gt;1; &#x2F;&#x2F; 取l、r中间值
	build(o&lt;&lt;1,l,mid); &#x2F;&#x2F; 先计算好左子树答案
	build(o&lt;&lt;1|1,mid+1,r); &#x2F;&#x2F; 再计算右子树答案
	pushup(o); &#x2F;&#x2F; 向上更新答案
    &#x2F;&#x2F;sumv[o]&#x3D;sumv[o&lt;&lt;1]+sumv[o&lt;&lt;1|1];
&#125;
&#x2F;* 修改单点的值 *&#x2F;
void change(int o,int l,int r,int q,int v)&#123; &#x2F;&#x2F; 将sumv[q]的数值加上v
	if(l&#x3D;&#x3D;r)&#123;sumv[o]+&#x3D;v;return;&#125; &#x2F;&#x2F; 递归到最后一个位置时，修改答案
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(q&lt;&#x3D;mid) change(o&lt;&lt;1,l,mid,q,v);
	else change(o&lt;&lt;1|1,mid+1,r,q,v);
	pushup(o); 
&#125;
&#x2F;* 查询某区间答案 *&#x2F;
int querysum(int o,int l,int r,int ql,int qr)&#123; &#x2F;&#x2F; 查询[ql,qr]的答案
	if(ql&lt;&#x3D;l &amp;&amp; r&lt;&#x3D;qr)return sumv[o]; &#x2F;&#x2F; 当递归访问到当前区间被包含于ql、qr之间时，直接返回区间答案
	int ans&#x3D;0;
	int mid&#x3D;(l+r)&gt;&gt;1; &#x2F;&#x2F; 注意这里不是（l+r+1）&gt;&gt;1，关系到下面两条语句的判断表达式
	if(ql&lt;&#x3D;mid) ans+&#x3D;querysum(o&lt;&lt;1,l,mid,ql,qr); &#x2F;&#x2F; ql位于左子树（包含当前这个根）
	if(qr&gt;mid) ans+&#x3D;querysum(o&lt;&lt;1|1,mid+1,r,ql,qr); &#x2F;&#x2F; qr位于右子树
	return ans;
&#125;
&#x2F;* 使用样例 *&#x2F;
int n,a[N]; &#x2F;&#x2F; 区间内有n个点需要维护，N为大于n的常数
int sumv[N&lt;&lt;2]; &#x2F;&#x2F; 线段树的数组存储方式，最底层有n个结点所构成的完全二叉树一共有2n-1个结点，一般取4n保险
int main()&#123;
    cin&gt;&gt;n&gt;&gt;m; &#x2F;&#x2F; n个数，m次操作
    for(int i&#x3D;1;i&lt;&#x3D;n;++i) cin&gt;&gt;a[i];
    build(1,1,n); &#x2F;&#x2F; 建树
    while(m--)&#123;
		int opt;cin&gt;&gt;opt; &#x2F;&#x2F; opt&#x3D;&#x3D;1，让x的位置数值增加y；opt&#x3D;&#x3D;2，查询区间[l,r]答案
		if(opt&#x3D;&#x3D;1)&#123;int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);change(1,1,n,x,y);&#125;
		if(opt&#x3D;&#x3D;2)&#123;int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r);printf(&quot;%d\n&quot;,querysum(1,1,n,l,r));&#125;
	&#125;
&#125;</code></pre>

<ul>
<li><font size=4 color=blue>再以维护区间最大值为例，建立线段树</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">void pushup(int o)&#123;maxv[o]&#x3D;max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);&#125; &#x2F;&#x2F; 向上更新
&#x2F;* 建立线段树 *&#x2F;
void build(int o,int l,int r)&#123;
	if(l&#x3D;&#x3D;r)&#123;maxv[o]&#x3D;a[l];return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	build(o&lt;&lt;1,l,mid);
	build(o&lt;&lt;1|1,mid+1,r);
	pushup(o);
    &#x2F;&#x2F;maxv[o]&#x3D;max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);
&#125;
&#x2F;* 修改单点的值 *&#x2F;
void change(int o,int l,int r,int q,int v)&#123; &#x2F;&#x2F; 将sumv[q]的数值加上v
	if(l&#x3D;&#x3D;r)&#123;maxv[o]+&#x3D;v;return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(q&lt;&#x3D;mid)change(o&lt;&lt;1,l,mid,q,v);
	else change(o&lt;&lt;1|1,mid+1,r,q,v);
	pushup(o); 
&#125;
&#x2F;* 查询某区间答案 *&#x2F;
int querymax(int o,int l,int r,int ql,int qr)&#123; &#x2F;&#x2F; 查询[ql,qr]的答案
	if(ql&lt;&#x3D;l &amp;&amp; r&lt;&#x3D;qr)return maxv[o];
	int ans&#x3D;1e9+7;
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(ql&lt;&#x3D;mid) ans &#x3D; max(ans,querymax(o&lt;&lt;1,l,mid,ql,qr));
	if(qr&gt;mid) ans &#x3D; max(ans,querymax(o&lt;&lt;1|1,mid+1,r,ql,qr));
	return ans;
&#125;</code></pre>

<ul>
<li><font size=4 color=red>第二阶段：带标记优化，只有需要访问时才需要返回正确结果，不许要访问的区间若要进行修改，暂时打上标记就行，等需要查询的时候再修改为正确答案</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
const int N&#x3D;1e6+10;
int n,a[N],m;
int sumv[N&lt;&lt;2],addv[N&lt;&lt;2];
&#x2F;&#x2F;以维护区间和为例
void pushup(int o)&#123;sumv[o]&#x3D;sumv[o&lt;&lt;1]+sumv[o&lt;&lt;1|1];&#125;
void build(int o,int l,int r)&#123;
	&#x2F;&#x2F;build函数没改动
	if(l&#x3D;&#x3D;r)&#123;sumv[o]&#x3D;a[l];return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	build(o&lt;&lt;1,l,mid);
	build(o&lt;&lt;1|1,mid+1,r);
	pushup(o);
&#125;
&#x2F;* 设置标记 *&#x2F;
inline void puttag(int o,int l,int r,int v)&#123;
    &#x2F;* 注意标记与线段树要同时修改 *&#x2F;
	addv[o]+&#x3D;v; &#x2F;&#x2F; 标记增加v
    sumv[o]+&#x3D;(r-l+1)*v; &#x2F;&#x2F; 总和增加了（区间长度*v）
&#125;
&#x2F;* 下放标记：将当前位置的标记下放到左右两子区间上 *&#x2F;
void pushdown(int o,int l,int r)&#123;
	if(addv[o]&#x3D;&#x3D;0)return; &#x2F;&#x2F; 若无标记，直接返回
	addv[o&lt;&lt;1]+&#x3D;addv[o]; &#x2F;&#x2F; 将当前标记放到左右两子树上
	addv[o&lt;&lt;1|1]+&#x3D;addv[o];
	int mid&#x3D;(l+r)&gt;&gt;1;
	sumv[o&lt;&lt;1]+&#x3D;addv[o]*(mid-l+1); &#x2F;&#x2F; 修改左子树总和：增加了(标记*左子区间长度）
	sumv[o&lt;&lt;1|1]+&#x3D;addv[o]*(r-mid); &#x2F;&#x2F; 修改右子树总和：增加了(标记*右子区间长度）
	addv[o]&#x3D;0; &#x2F;&#x2F; 当前标记清零
&#125;
&#x2F;* 区间[ql,qr]每个点都增加v *&#x2F;
void optadd(int o,int l,int r,int ql,int qr,int v)&#123;
	if(ql&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;qr)&#123;puttag(o,l,r,v);return;&#125; &#x2F;&#x2F; 当前区间被需要修改的区间包含，直接打上标记
	int mid&#x3D;(l+r)&gt;&gt;1;
	pushdown(o,l,r); &#x2F;&#x2F; 在往后打上新的标记前，需要将祖先的标记下放
	if(ql&lt;&#x3D;mid)optadd(o&lt;&lt;1,l,mid,ql,qr,v);
	if(qr&gt;mid)optadd(o&lt;&lt;1|1,mid+1,r,ql,qr,v);
	pushup(o); &#x2F;&#x2F; 注意修改的时候函数体一定要有pushup;
&#125;
&#x2F;* 查询某区间答案 *&#x2F;
int querysum(int o,int l,int r,int ql,int qr)&#123;
	if(ql&lt;&#x3D;l &amp;&amp; r&lt;&#x3D;qr) return sumv[o]; &#x2F;&#x2F; 直接返回被包含区间的答案
	int ans&#x3D;0;int mid&#x3D;(l+r)&gt;&gt;1;
	pushdown(o,l,r); &#x2F;&#x2F; 需要算子区间答案时，要将祖先区间的所有标记下放到子区间上
	if(ql&lt;&#x3D;mid) ans +&#x3D; querysum(o&lt;&lt;1,l,mid,ql,qr);
	if(qr&gt;mid) ans +&#x3D; querysum(o&lt;&lt;1|1,mid+1,r,ql,qr);
	return ans;
&#125;
&#x2F;* 使用样例 *&#x2F;
int main()&#123;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;a[i];
	build(1,1,n);
	while(m--)&#123;
		int opt;cin&gt;&gt;opt;
		if(opt&#x3D;&#x3D;1)&#123;
            int l,r,v;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;
            optadd(1,1,n,l,r,v);
        &#125;
		if(opt&#x3D;&#x3D;2)&#123;
            int l,r;
            cin&gt;&gt;l&gt;&gt;r;
            cout&lt;&lt;querysum(1,1,n,l,r);
        &#125;
	&#125;
&#125;</code></pre>

<ul>
<li><p><font size=4 color=red>第三阶段：同时维护多种标记</font></p>
</li>
<li><p><font size=4>以加法和乘法为例：</font></p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
const int N&#x3D;1e6+10;
int n,a[N],m;
int sumv[N&lt;&lt;2],addv[N&lt;&lt;2],prov[N&lt;&lt;2]; &#x2F;&#x2F; addv是加法标记、prov是乘法标记
void pushup(int o)&#123;sumv[o]&#x3D;(sumv[o&lt;&lt;1]+sumv[o&lt;&lt;1|1]);&#125;
void build(int o,int l,int r)&#123;
	prov[o]&#x3D;1; &#x2F;&#x2F; 加法标记addv初始化为0，乘法标记prov初始化为1
	if(l&#x3D;&#x3D;r)&#123;sumv[o]&#x3D;a[l];return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	build(o&lt;&lt;1,l,mid);
	build(o&lt;&lt;1|1,mid+1,r);
	pushup(o);
&#125;
void pushdown(int o,int l,int r)&#123; &#x2F;&#x2F; 需要考虑多种标记的冲突问题
	if(addv[o]&#x3D;&#x3D;0&amp;&amp;prov[o]&#x3D;&#x3D;1)return; &#x2F;&#x2F; 当前无特殊标记
    &#x2F;* 若有标记 *&#x2F;
	int mid&#x3D;(l+r)&gt;&gt;1;
    &#x2F;* 修改左右子区间的总和为：原总和×当前乘法标记+子区间长度×当前加法标记 *&#x2F;
	sumv[o&lt;&lt;1]  &#x3D; sumv[o&lt;&lt;1]*prov[o]+addv[o]*(mid-l+1);
	sumv[o&lt;&lt;1|1]&#x3D; sumv[o&lt;&lt;1|1]*prov[o]+addv[o]*(r-mid);
    &#x2F;* 当前的乘法标记下放到左、右子区间 *&#x2F;
	prov[o&lt;&lt;1]  *&#x3D; prov[o];
	prov[o&lt;&lt;1|1]*&#x3D; prov[o];
    &#x2F;* 修改左、右子区间的加法标记为：子区间加法标记×当前乘法标记+当前加法标记 *&#x2F;
	addv[o&lt;&lt;1]  &#x3D; addv[o&lt;&lt;1]*prov[o]+addv[o];
	addv[o&lt;&lt;1|1]&#x3D; addv[o&lt;&lt;1|1]*prov[o]+addv[o];
    &#x2F;* 清零标记 *&#x2F;
	addv[o]&#x3D;0;
	prov[o]&#x3D;1;
&#125;
&#x2F;* [ql,qr]区间每个数都乘上k *&#x2F;
void optpro(int o,int l,int r,int ql,int qr,int k)&#123;
	if(ql&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;qr)&#123; &#x2F;&#x2F; 当前区间被需要修改的区间包含，直接打上标记
		if(addv[o])pushdown(o,l,r); &#x2F;&#x2F; 特判：若当前有加法标记，则需下放
		sumv[o]*&#x3D;k;
		prov[o]*&#x3D;k;	
		return;
	&#125;
	pushdown(o,l,r); &#x2F;&#x2F; 考虑这句话的意义？
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(ql&lt;&#x3D;mid) optpro(o&lt;&lt;1,l,mid,ql,qr,k);
	if(qr&gt;mid) optpro(o&lt;&lt;1|1,mid+1,r,ql,qr,k);
	pushup(o);
&#125;
&#x2F;* [ql,qr]区间每个数都加上v *&#x2F;
void optadd(int o,int l,int r,int ql,int qr,int v)&#123;
	if(ql&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;qr)&#123; &#x2F;&#x2F; 当前区间被需要修改的区间包含，直接打上标记
		sumv[o]+&#x3D;v*(r-l+1);
		addv[o]+&#x3D;v;
		return;
	&#125;
    pushdown(o,l,r);
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(ql&lt;&#x3D;mid)optadd(o&lt;&lt;1,l,mid,ql,qr,v);
	if(qr&gt;mid)optadd(o&lt;&lt;1|1,mid+1,r,ql,qr,v);
	pushup(o);
&#125;
&#x2F;* 查询[ql,qr]区间答案 *&#x2F;
int querysum(int o,int l,int r,int ql,int qr)&#123;
	if(ql&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;qr) return sumv[o];
	int ans&#x3D;0;
	int mid&#x3D;(l+r)&gt;&gt;1;
	pushdown(o,l,r);
	if(ql&lt;&#x3D;mid) ans +&#x3D; querysum(o&lt;&lt;1,l,mid,ql,qr);
	if(qr&gt;mid) ans +&#x3D; querysum(o&lt;&lt;1|1,mid+1,r,ql,qr);
	return ans;
&#125;
&#x2F;* 使用样例：选择1、2、3分别是乘法、加法、查询 *&#x2F;
int main()&#123;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;a[i];
	build(1,1,n);
	while(m--)&#123;
		int opt;cin&gt;&gt;opt;
		if(opt&#x3D;&#x3D;1)&#123;
            int l,r,v;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;
            optpro(1,1,n,l,r,v);
        &#125;
        if(opt&#x3D;&#x3D;2)&#123;
            int l,r,v;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;
            optadd(1,1,n,l,r,v);
        &#125;
		if(opt&#x3D;&#x3D;3)&#123;
            int l,r;
            cin&gt;&gt;l&gt;&gt;r;
            cout&lt;&lt;querysum(1,1,n,l,r)&lt;&lt;endl;
        &#125;
	&#125;
	return 0;
&#125;</code></pre>



<h3 id="3、主席树（可持久化线段树）"><a href="#3、主席树（可持久化线段树）" class="headerlink" title="3、主席树（可持久化线段树）"></a>3、主席树（可持久化线段树）</h3><ul>
<li><font size=4 color=blue>可持久化的含义是：可以任意回退到某种历史状态</font></li>
<li><font size=4 color=blue>例题：给定一个数列a[n](n&lt;=2e5、a[i]&lt;=2e5)，m次查询[l,r]区间第k小的数</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define M 20005
using namespace std;
struct tree &#123;
	int cnt; &#x2F;&#x2F; 每个结点保存了左右子树上某些数出现的次数，最底层的结点保存的数就是某一个数出现的次数
	tree *lson,*rson;
&#125;mem[M&lt;&lt;5],*top[M]; &#x2F;&#x2F; mem提前开好空间，top是连续时间戳上的线段树的根节点
int spaceNum; &#x2F;&#x2F; spaceNum记录分配内存的数量
void build(tree* t,int l,int r)&#123;
    &#x2F;* build是建立初始的线段树，每个数出现的个数均初始化为0 *&#x2F;
	if(l&#x3D;&#x3D;r)&#123;t-&gt;cnt&#x3D;0;return;&#125; 
	int mid&#x3D;(l+r)&gt;&gt;1;
    &#x2F;* 左右儿子内存分配 *&#x2F;
	t-&gt;lson&#x3D;&amp;mem[++spaceNum];
	t-&gt;rson&#x3D;&amp;mem[++spaceNum];
	build(t-&gt;lson,l,mid);
	build(t-&gt;rson,mid+1,r);
	t-&gt;cnt&#x3D;0; 
&#125;
void insert(tree* last,tree* now,int l,int r,int x)&#123;
    &#x2F;* 从头开始遍历a数组，每次向线段树里插入a[i]，表示区间[1,i]上每个数字出现的次数 *&#x2F;
    &#x2F;* 由此，时间戳上每颗线段树（除了第一个初始化的）都是通过前一棵树演变过来的 *&#x2F;
    &#x2F;* 相邻两颗树仅有logn个结点不同，即仅更改了一条路径的结点 *&#x2F;
    &#x2F;* 对于其他没变化的结点，新树共用旧树的结点，不会浪费空间（这就是用指针的妙处）*&#x2F;
	if(l&#x3D;&#x3D;r)&#123;now-&gt;cnt&#x3D;last-&gt;cnt+1;return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	*now&#x3D;*last; &#x2F;&#x2F; 新树的根初始化与旧树的根相同
    &#x2F;* 判断新加入的x在左子树还是右子树 *&#x2F;
	if(x&lt;&#x3D;mid)&#123;
		now-&gt;lson&#x3D;&amp;mem[++spaceNum];
		insert(last-&gt;lson,now-&gt;lson,l,mid,x);
	&#125;
	else&#123;
		now-&gt;rson&#x3D;&amp;mem[++spaceNum];
		insert(last-&gt;rson,now-&gt;rson,mid+1,r,x);
	&#125;
	now-&gt;cnt &#x3D; now-&gt;lson-&gt;cnt + now-&gt;rson-&gt;cnt; &#x2F;&#x2F; 相当于pushup
&#125;
int query(tree *lastTree,tree *nowTree,int l,int r,int x)&#123;
    &#x2F;* 查询区间[l,r]上第x小的数 *&#x2F;
	if(l&#x3D;&#x3D;r)return l;
	int mid&#x3D;(l+r)&gt;&gt;1;
    &#x2F;* 比较两树的左儿子计数的差与x的大小：如果前者不小于后者，说明所求的第x小的数在左子树上 *&#x2F;
	int temp&#x3D;nowTree-&gt;lson-&gt;cnt - lastTree-&gt;lson-&gt;cnt;
	if(x&lt;&#x3D;temp)return query(lastTree-&gt;lson,nowTree-&gt;lson,l,mid,x);
    &#x2F;* 若后者大于前者，则需要在右子树上求第(x-temp)小的数 *&#x2F;
	else return query(lastTree-&gt;rson,nowTree-&gt;rson,mid+1,r,x-temp);
&#125;
&#x2F;* 使用样例 *&#x2F;
int main()&#123;
    int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;0;i&lt;&#x3D;n;++i)top[i]&#x3D;&amp;mem[++spaceNum]; 
	build(top[0],1,n);
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)insert(top[i-1],top[i],1,n,a[i]);
	while(m--)&#123;
		int l,r,x;
		cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;
		cout&lt;&lt;query(top[l-1],top[r],1,n,x)&lt;&lt;endl;
	&#125;
	return 0;
&#125;</code></pre>



<h3 id="4、树状数组（Binary-Indexed-Tree）"><a href="#4、树状数组（Binary-Indexed-Tree）" class="headerlink" title="4、树状数组（Binary Indexed Tree）"></a>4、树状数组（Binary Indexed Tree）</h3><ul>
<li><p><font size=4 color=blue>求区间<code>[ql,qr]</code>的和，其实只要能求对任意i的区间<code>[1,i]</code>即可，因为<code>[ql,qr]=[1,qr]-[1,ql-1]</code>，也就是说，线段树中右儿子是不必要的，因为有了左儿子和父亲，就能求右儿子的值。</font></p>
</li>
<li><p><font size=4 color=blue>基于这种思路的数据结构就是树状数组。它有着与线段树同样的时间复杂度，但是树状数组的常数更小，代码更短，应用范围也比线段树更加广泛</font></p>
</li>
<li><p>```c++<br>/* 观察树状数组的构造规律 */<br>c[1]=a[1];<br>c[2]=a[1]+a[2];<br>c[3]=a[3];<br>c[4]=a[1]+a[2]+a[3]+a[4];<br>c[5]=a[5];<br>c[6]=a[5]+a[6];<br>c[7]=a[7];<br>c[8]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8];<br>// 1–&gt;0001<br>// 2–&gt;0010<br>// 3–&gt;0011<br>// 4–&gt;0100<br>// 5–&gt;0101<br>// 6–&gt;0110<br>// 7–&gt;0111<br>// 8–&gt;1000</p>
<pre class="language-none"><code class="language-none">
- &lt;font size&#x3D;4&gt;规律：$i$的二进制中从右往左数有$x$个连续的0，那么拥有$2^x$个叶子，为序列A中第$i-2^x+1$到第$i$个元素（共$2^x$个元素）的和。具体求和过程如下：&lt;&#x2F;font&gt;

  - &#96;&#96;&#96;c++
    &#x2F;* 以求s[7]为例 *&#x2F;
    &#x2F;&#x2F; 7--&gt;0111
    c[7]&#x3D;a[7];
    &#x2F;&#x2F; 减去其二进制最后一个1，得0110
    c[6]&#x3D;a[6]+a[5];
    &#x2F;&#x2F; 减去其二进制最后一个1，得0100
    c[4]&#x3D;a[4]+a[3]+a[2]+a[1];
    &#x2F;&#x2F; 减去其二进制最后一个1，得0000，结果为0，结束</code></pre></li>
<li><p><font size=4 color=blue>上述求二进制位最低1的操作被称为lowbit，lowbit函数的实现方法有很多：</font></p>
<ul>
<li>最常见是这种：<code>x &amp; -x</code></li>
<li>若不支持访问负数，可以写成：<code>x &amp; ( x^(x-1) )</code></li>
<li>每次做的这个操作：<code>x -= x &amp; -x</code>，可以写作<code>x = x &amp; (x-1)</code></li>
</ul>
</li>
<li><p><font size=4 color=red>例：O(logn)维护单点修改、区间查询</font></p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define M 10010
#define lowbit(x) x &amp; -x
using namespace std;
int c[M],n; &#x2F;&#x2F; c数组保存了一定的a[]序列中的数
int sum(int x)&#123; &#x2F;&#x2F; 求区间[1,x]的和
    int ans &#x3D; 0;
    while(x &gt; 0)&#123;
        ans +&#x3D; c[x];
        x -&#x3D; lowbit(x);
    &#125;
    return ans;
&#125;
&#x2F;* 单点修改的时候复杂度也为O(logn)，只需要修改某些相关联的c[i]即可 *&#x2F;
void add(int x,int value)&#123;
    &#x2F;* 正好求c[i]的祖先只需要让i加上自己的lowbit *&#x2F;
    while(x &lt;&#x3D; n)&#123;
        c[x] +&#x3D; value;
        x +&#x3D; lowbit(x);
    &#125;
&#125;
&#x2F;* 使用样例：输入区间长度、操作数、每个点的值，每次操作：1 x y表示点x加y，2 x y表示查询区间[x,y] *&#x2F;
int main()&#123;
	int opt,x,y;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;
		cin&gt;&gt;x;
		add(i,x);
	&#125;
	while(m--)&#123;
		cin&gt;&gt;opt&gt;&gt;x&gt;&gt;y;
		if(opt&#x3D;&#x3D;1)add(x,y);
		else if(opt&#x3D;&#x3D;2)cout&lt;&lt;sum(y)-sum(x-1)&lt;&lt;endl;
	&#125;
	return 0;
&#125;</code></pre>

<ul>
<li><font size=4 color=red>变形（树状数组+差分思想）：O(logn)维护区间修改、单点查询</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define M 500010
using namespace std;
int c[M],n,m;
&#x2F;* sum函数与add函数不变 *&#x2F;
&#x2F;* c数组维护的是差分，从而sum(i)求得a[i]的值 *&#x2F;
&#x2F;* 使用样例 *&#x2F;
int main()&#123;
	int opt,x,y,k,c0 &#x3D; 0,c1;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;
        &#x2F;* 每次读入初始单点后，记录差分，并修改c数组 *&#x2F;
		cin&gt;&gt;c1;
		add(i,c1-c0);
		c0&#x3D;c1;
	&#125;
	while(m--)&#123;
		cin&gt;&gt;opt;
		if(opt&#x3D;&#x3D;1)&#123;
			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;
			add(x,k);
			add(y+1,-k);
		&#125;
		else if(opt&#x3D;&#x3D;2)&#123;
			cin&gt;&gt;k;
			cout&lt;&lt;sum(k)&lt;&lt;endl;
		&#125;
	&#125;
	return 0;
&#125;</code></pre>




<h3 id="5、ST表"><a href="#5、ST表" class="headerlink" title="5、ST表"></a>5、ST表</h3><ul>
<li><font size=4 color=blue>给定一个长度为n的序列不修改，m次查询区间的最大值</font></li>
<li><font size=4>对区间内每个点都维护一个从自身到往后2^0^、2^1^、2^2^……个元素组成子区间的答案（总额外空间为nlogn），用二维数组保存这些答案，逻辑上2^0^为第一层、2^1^为第二层……；</font></li>
<li><font size=4>查询时只需要访问（不大于查询区间长度的2的幂次层）答案即可。即若查询区间长度为10，则访问两个2^3^=8的层。</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">void bulid()&#123;
	for(int j &#x3D; 1;j &lt;&#x3D; 16; j++) &#x2F;&#x2F; j是层数
		for(int i &#x3D; 1;i &lt;&#x3D; n; i++)
			f[j][i] &#x3D; max(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]); 
    		&#x2F;&#x2F; 上一层中的两个子区间答案的合并
    		&#x2F;&#x2F; 即1、2与3、4的最大值是1、2、3、4的最大值
&#125;
&#x2F;* 使用样例 *&#x2F;
#define M 100010
int f[17][M],b[M],n,m;
int main()&#123;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;f[0][i];
	bulid();
    &#x2F;* b[len]：给定区间长度len，返回对应层数 *&#x2F;
	for(int i&#x3D;1;i&lt;&#x3D;16;i++)b[1&lt;&lt;i]++;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)b[i]+&#x3D;b[i-1];
	for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;
        int l,r,len;
        cin&gt;&gt;l&gt;&gt;r;
        len&#x3D;r-l+1;
		cout&lt;&lt;max( f[ b[len] ][l],f[ b[len] ][ r+1- (1&lt;&lt;b[len] ) ])
	&#125;
	return 0;
&#125;</code></pre>

<table>
<thead>
<tr>
<th align="center">数组</th>
<th align="center">5</th>
<th align="center">7</th>
<th align="center">12</th>
<th align="center">9</th>
<th align="center">6</th>
<th align="center">4</th>
<th align="center">8</th>
<th align="center">11</th>
<th align="center">3</th>
<th align="center">9</th>
<th align="center">1</th>
<th align="center">6</th>
<th align="center">2</th>
<th align="center">10</th>
<th align="center">7</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2^1^=2</td>
<td align="center">7</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">9</td>
<td align="center">6</td>
<td align="center">8</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">6</td>
<td align="center">6</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2^2^=4</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">9</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2^3^=8</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">×</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">×</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><font size=4>查询从第4个（9）数到第14个数（10）中的最大值：区间长度为11，查2^3^那层（两×位置）最大值为11。</font></li>
</ul>
<h3 id="6、二叉树求先序遍历"><a href="#6、二叉树求先序遍历" class="headerlink" title="6、二叉树求先序遍历"></a>6、二叉树求先序遍历</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
void ans(string z,string h)
&#123;
	if(z.size())
	&#123;
		char c&#x3D;h[h.size()-1];
		cout&lt;&lt;c;
		int t&#x3D;z.find(c);
		ans(z.substr(0,t),h.substr(0,t));
		ans(z.substr(t+1),h.substr(t,z.size()-t-1));
	&#125;
&#125;
int main()
&#123;
	string z,h;
	cin&gt;&gt;z&gt;&gt;h;
	ans(z,h);
	return 0; 
&#125; </code></pre>

<h3 id="7、先序中序还原二叉树（整数）"><a href="#7、先序中序还原二叉树（整数）" class="headerlink" title="7、先序中序还原二叉树（整数）"></a>7、先序中序还原二叉树（整数）</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
vector&lt;int&gt; inorder, preorder;
class treeNode&#123;
public:
    int val;
    treeNode* left;
    treeNode* right;
    treeNode(int v): val(v)&#123;
        left &#x3D; right &#x3D; NULL;
    &#125;
&#125;;
treeNode* make(int ii, int ij, int pi, int pj)&#123; &#x2F;&#x2F; 关键递归函数，注意细节
    if(ii &gt; ij) return NULL;
    treeNode* root &#x3D; new treeNode(preorder[pi]); &#x2F;&#x2F; 取先序遍历的第一个作为根
    int ind &#x3D; find(inorder.begin() + ii, inorder.begin() + ij + 1, root-&gt;val) - inorder.begin(); &#x2F;&#x2F; 在中序遍历中寻找这个根
    root-&gt;left &#x3D; make(ii, ind - 1, pi + 1, ind - ii + pi); &#x2F;&#x2F; 第四个参数是计算而得
    root-&gt;right &#x3D; make(ind + 1, ij, pj - ij + ind + 1, pj); &#x2F;&#x2F; 第三个参数计算而得
    return root;
&#125;
int main()&#123;
    int n; cin&gt;&gt;n;
    inorder.resize(n);
    preorder.resize(n);
    for(int i &#x3D; 0; i &lt; n; ++i)&#123;
        cin&gt;&gt;inorder[i];
    &#125;
    for(int i &#x3D; 0; i &lt; n; ++i)&#123;
        cin&gt;&gt;preorder[i];
    &#125;
    treeNode* root &#x3D; make(0, n - 1, 0, n - 1);
    return 0;
&#125;
</code></pre>





<h3 id="2、字符串匹配算法——KMP"><a href="#2、字符串匹配算法——KMP" class="headerlink" title="2、字符串匹配算法——KMP"></a>2、字符串匹配算法——KMP</h3><ul>
<li><font size=4 color=blue>概念不再赘述，复杂度为O(n+m)</font></li>
<li><font size=4>匹配失败时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符的next值</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;* 求next数组 *&#x2F;
&#x2F;&#x2F; 方法一：next数组初始化为0
for(int i &#x3D; 1, j &#x3D; 0; i &lt; s.size(); ++i)&#123; &#x2F;&#x2F; s是子串，求子串的next数组
    while(j &amp;&amp; s[i] !&#x3D; s[j]) j &#x3D; next[j-1]; &#x2F;&#x2F; j&#x3D;&#x3D;0表示不能再往回跳了
    if(s[j] &#x3D;&#x3D; s[i]) j++;
    kmp[i] &#x3D; j;
&#125;
&#x2F;&#x2F; 方法二：next[0]初始化为-1，其余为0，next[i]的值是i-1位字符的next值
next[0] &#x3D; -1;
int i &#x3D; 0, j &#x3D; -1;
while (i &lt; s.size() - 1) &#123;
    if (j &#x3D;&#x3D; -1 || p[i] &#x3D;&#x3D; p[j])
        next[++i] &#x3D; ++j;
    else
        j &#x3D; next[j];
&#125;
&#x2F;* 匹配过程 *&#x2F;
&#x2F;&#x2F; 由于子串的下标是从0开始，next[j]既可表示当前字符匹配了多长前缀，还能表示需要与子串的哪个位置做新一轮比较
for(int i &#x3D; 0, j &#x3D; 0; i &lt; str.size(); ++i)&#123;
    while(j &amp;&amp; s[j] !&#x3D; str[i]) j &#x3D; next[j-1]; &#x2F;&#x2F; j不为子串的开头、且当前字符不匹配时，向前跳
    if(s[j] &#x3D;&#x3D; str[i]) j++; &#x2F;&#x2F; 当前字符串匹配
    if(j &#x3D;&#x3D; s.size())&#123; &#x2F;&#x2F; 当匹配数与子串长度相等时，匹配成功
        cout&lt;&lt;i-s.size()+2&lt;&lt;endl; &#x2F;&#x2F; 输出位置(下标为1开始)
        j &#x3D; next[j-1]; &#x2F;&#x2F; j向前跳一次
    &#125;
&#125;</code></pre>



<h3 id="3、字符串匹配算法——Sunday"><a href="#3、字符串匹配算法——Sunday" class="headerlink" title="3、字符串匹配算法——Sunday"></a>3、字符串匹配算法——Sunday</h3><ul>
<li><font size=4 color=blue>Sunday算法，理解起来则是非常容易，平均时间复杂度为O(n)，但最坏的情况下是O(n*m)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;* 预处理move数组：move[&#39;i&#39;]&#x3D;模式串长度-&#39;i&#39;字符在模式串中最后出现时的下标，move[其他]&#x3D;模式串长度+1 *&#x2F;
#define M 210
int move[M];
for(int i &#x3D; 0; i &lt; M; ++i) move[i]&#x3D;s.size() + 1;
for(int i &#x3D; 0; i &lt; s.size(); ++i) move[s[i]] &#x3D; s.size() - i;
&#x2F;* 具体匹配过程 *&#x2F;
int i &#x3D; 0,j; &#x2F;&#x2F; i表示主串匹配位置，j是模式串匹配位置
while(i &lt;&#x3D; str.size() - s.size())&#123;
    j &#x3D; 0;
    while(str[i+j] &#x3D;&#x3D; s[j])&#123;
        ++j;
        ++i;
        if(j &#x3D;&#x3D; s.size()) cout&lt;&lt;i&lt;&lt;endl; &#x2F;&#x2F; 匹配成功
        continue;
    &#125;
    i +&#x3D; move[s[i + s.size()]]; &#x2F;&#x2F; 取模式串结束位置的下一个位置在主串中的字符c，i移动move[c]的距离
&#125;</code></pre>

<ul>
<li>看上去简单高效非常美好的Sunday算法，也有一些缺点。例如下面一个例子：<ul>
<li>主串：baaabaaabaaa、模式串：aaaa</li>
<li>这个模式串使得move[a]的值为1，即每次匹配失败时，只让模式串向后移动一位再进行匹配。这样就让Sunday算法的时间复杂度飙升到了O(m*n)，也就是字符串匹配的最坏情况</li>
</ul>
</li>
</ul>
<h2 id="五、排序"><a href="#五、排序" class="headerlink" title="五、排序"></a>五、排序</h2><h3 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h3><ul>
<li><font size=4 color=red>裸模板：尚未优化（容易被卡死）：</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define M 100010
int a[M];
void qsort(int low,int high)&#123;
    if(low&gt;&#x3D;high)
        return ;
    int i&#x3D;low,j&#x3D;high,k&#x3D;a[low];
    while(i&lt;j)&#123;
        while(i&lt;j&amp;&amp;a[j]&gt;&#x3D;k)
            j--;
        if(i&lt;j)
            a[i++]&#x3D;a[j];
        while(i&lt;j&amp;&amp;a[i]&lt;&#x3D;k)
            i++;
        if(i&lt;j)
            a[j--]&#x3D;a[i];
    &#125;
    a[i]&#x3D;k;
    qsort(low,i-1);
    qsort(i+1,high);
&#125;</code></pre>



<h3 id="2、堆排序实现优先队列"><a href="#2、堆排序实现优先队列" class="headerlink" title="2、堆排序实现优先队列"></a>2、堆排序实现优先队列</h3><ul>
<li><font size=4 color=blue>用数组来维护完全二叉树，且满足任意父结点小于（或大于）其子结点，称其为小根堆（或大根堆）。插入、删除的复杂度O(logn)，查询最值复杂度O(1)</font></li>
<li><font size=4>插入过程：将新结点放入完全二叉树最后，并判断是否上浮</font></li>
<li><font size=4>弹出过程：完全二叉树最后一个结点替换掉根结点，并判断是否下沉</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;* 以下以整数小根堆为例 *&#x2F;
int minHeap[10010],mHnum&#x3D;0; &#x2F;&#x2F; 数组维护完全二叉树，mHnum是结点个数
void push(int ev)&#123;
	int num&#x3D;++mHnum; &#x2F;&#x2F; num是新结点的索引值
	bool flag&#x3D;true; &#x2F;&#x2F; 判断是否还需要上浮
	minHeap[num]&#x3D;ev; &#x2F;&#x2F; 将新值加入完全二叉树的最后
	while(num&#x2F;2 &amp;&amp; flag)&#123; &#x2F;&#x2F; 与父结点进行比较，直到自己是根结点或不需上浮
		flag&#x3D;false;
		if(minHeap[num] &lt; minHeap[num&#x2F;2])&#123;
			int temp&#x3D;minHeap[num];
			minHeap[num]&#x3D;minHeap[num&#x2F;2];
			minHeap[num&#x2F;2]&#x3D;temp;
			flag&#x3D;true;
			num&#x2F;&#x3D;2;
		&#125;
	&#125;
&#125;
void pop()&#123;
	if(mHnum&#x3D;&#x3D;0) return ; &#x2F;&#x2F; 小根堆为空 
	minHeap[1]&#x3D;minHeap[mHnum]; &#x2F;&#x2F; 根被替换
	minHeap[mHnum--] &#x3D; 0; &#x2F;&#x2F; 清除末尾结点
	int num&#x3D;1,better; &#x2F;&#x2F; num是新结点的索引值
	bool flag&#x3D;true; &#x2F;&#x2F; 判断是否还需要下沉
	while(num*2&lt;&#x3D;mHnum &amp;&amp; flag)&#123; &#x2F;&#x2F; 与子结点进行比较，直到自己没有子结点或不需下沉
		flag&#x3D;false;
		better&#x3D;num*2; &#x2F;&#x2F; better是子结点的索引值，需要比较左右两个儿子哪个与父亲交换
		if(better+1&lt;&#x3D;mHnum &amp;&amp; minHeap[num*2]&gt;minHeap[num*2+1]) better++; &#x2F;&#x2F; 右儿子更优
		if(minHeap[num]&gt;minHeap[better])&#123;
			int temp&#x3D;minHeap[num];
			minHeap[num]&#x3D;minHeap[better];
			minHeap[better]&#x3D;temp;
			flag&#x3D;true;
			num&#x3D;better;
		&#125;
	&#125;
&#125;</code></pre>









<h2 id="七、筛法"><a href="#七、筛法" class="headerlink" title="七、筛法"></a>七、筛法</h2><h3 id="1、埃氏（Eratosthenes）筛法"><a href="#1、埃氏（Eratosthenes）筛法" class="headerlink" title="1、埃氏（Eratosthenes）筛法"></a>1、埃氏（Eratosthenes）筛法</h3><ul>
<li><font size=4 color=blue>从2到n枚举整数i，若i没被标记，则i为质素；若i为质素，标记大于i且不大于n的i的倍数。复杂度为O(nloglogn)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">bool flag[N+1];
vector&lt;int&gt; p;
void sieve(int n)&#123;
    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;
        if(!flag[i])&#123;
            p.push_back(i);
            &#x2F;* 注意这个下面这个for语句要放在if内，否则会出现重复标记 *&#x2F;
            &#x2F;* 如4的倍数的标记已经被2标记过了，复杂度会降为O(nlogn) *&#x2F;
        	for(int j &#x3D; i*2; j &lt;&#x3D; N; j +&#x3D; i)
            	flag[j] &#x3D; true;
        &#125;
    &#125;
&#125;</code></pre>



<h3 id="2、线性筛（欧拉筛法）"><a href="#2、线性筛（欧拉筛法）" class="headerlink" title="2、线性筛（欧拉筛法）"></a>2、线性筛（欧拉筛法）</h3><ul>
<li><font size=4 color=blue>埃氏筛法中，一个非素数可能会有很多次被判断，比如12，可以有2×6排除，3×4排除。如果可以避免这些重复，那么复杂度就可以再降到O(n)</font></li>
<li><font size=4 color=blue>从2到n枚举整数i，再从小到大枚举所有不大于i的最小质因子的质素p0，标记ip0。显然，枚举到的p0总是ip0的最小质因子，而更大的p0均不可能是ip0的最小质因子。同样，枚举到i时，若i没有被标记过，则i为质数</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">bool flag[N+1];
vector&lt;int&gt; p; &#x2F;&#x2F; 依次保存n以内的质素
void sieve(int n)&#123;
    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;
        if(!flag[i]) p.push_back(i); &#x2F;&#x2F; i为质素，直接放入p内
    	for(int j &#x3D; 0; i*p[j] &lt;&#x3D; N; ++j)&#123;
        	flag[i*p[j]] &#x3D; true;
        	if(i%p[j] &#x3D;&#x3D; 0)break; &#x2F;&#x2F; 关键一步
        &#125;
    &#125;
&#125;</code></pre>

<ul>
<li><font size=4>从质因数分解的角度看，任意一个正整数（除了1以外）都可以分解成一个质素乘另一个数，不妨要求这个质素尽可能小。比如原本对于整数12来说，经过了2次标记（2×6、3×4），但是按照要求只有2的6倍能对12进行标记，但是如何舍去3×4呢？</font></li>
<li><font size=4>其实代码的执行过程并不是主动舍弃多余的，而是直接略过可能发生重复的。具体过程像这样：</font><ul>
<li>2筛去了4；</li>
<li>3筛去了6、9；</li>
<li>4筛去了8；（由于4%2==0，不会进行“4×3”的置true步骤）</li>
<li>5筛去了10、15、25；</li>
<li>6筛去了12（由于6%2==0，不会进行“6×3”的步骤，而18最后会被“2×9”筛去</li>
<li>……</li>
</ul>
</li>
<li><font size=4>总而言之，每个将被标记的数只会被其因数中最小质素标记，仅有一次，这样就把复杂度降低了</font></li>
</ul>

  </div>
  <div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/2021/01/17/LeetCode第224场周赛/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">LeetCode第224场周赛 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/2020/07/04/字符串高精度运算/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">字符串高精度运算 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">一、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1、背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-01%E8%83%8C%E5%8C%85-gt"><span class="toc-text">&lt;01背包&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-gt"><span class="toc-text">&lt;完全背包&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%9D%E7%A6%BB"><span class="toc-text">2、字符串距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B1%82%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-text">3、求最大连续子序列和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9B%BE%E8%AE%BA"><span class="toc-text">二、图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">1、图的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">2、单源最短路问题——Dijkstra算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Bellman-Ford%E7%AE%97%E6%B3%95"><span class="toc-text">3、单源最短路问题——Bellman-Ford算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Floyd-Warshall%E7%AE%97%E6%B3%95"><span class="toc-text">4、多源最短路问题——Floyd-Warshall算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E8%BF%98%E5%8E%9F"><span class="toc-text">5、最短路径还原</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Prim%E7%AE%97%E6%B3%95"><span class="toc-text">6、最小生成树——Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">7、最小生成树——Kruskal算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E2%80%94%E2%80%94Tarjan%E7%AE%97%E6%B3%95"><span class="toc-text">8、强连通分量——Tarjan算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94LCA%EF%BC%88Lowest-Common-Ancestor%EF%BC%89"><span class="toc-text">9、最近公共祖先问题——LCA（Lowest Common Ancestor）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">三、高级数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">1、并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88segment-Tree%EF%BC%89"><span class="toc-text">2、线段树（segment Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89"><span class="toc-text">3、主席树（可持久化线段树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88Binary-Indexed-Tree%EF%BC%89"><span class="toc-text">4、树状数组（Binary Indexed Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81ST%E8%A1%A8"><span class="toc-text">5、ST表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">6、二叉树求先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%89"><span class="toc-text">7、先序中序还原二叉树（整数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94KMP"><span class="toc-text">2、字符串匹配算法——KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Sunday"><span class="toc-text">3、字符串匹配算法——Sunday</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-text">五、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">1、快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-text">2、堆排序实现优先队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%AD%9B%E6%B3%95"><span class="toc-text">七、筛法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%83%E6%B0%8F%EF%BC%88Eratosthenes%EF%BC%89%E7%AD%9B%E6%B3%95"><span class="toc-text">1、埃氏（Eratosthenes）筛法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%88%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%89"><span class="toc-text">2、线性筛（欧拉筛法）</span></a></li></ol></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/img.jpg" class="author-img">

<p class="author-name">Monologue</p>
<p class="author-description">！(ง •̀_•́)ง Keep coding！</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>26</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>5</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>4</span>
    <span>标签</span>
  </a>
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">一、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1、背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-01%E8%83%8C%E5%8C%85-gt"><span class="toc-text">&lt;01背包&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-gt"><span class="toc-text">&lt;完全背包&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%9D%E7%A6%BB"><span class="toc-text">2、字符串距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B1%82%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-text">3、求最大连续子序列和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9B%BE%E8%AE%BA"><span class="toc-text">二、图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">1、图的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">2、单源最短路问题——Dijkstra算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Bellman-Ford%E7%AE%97%E6%B3%95"><span class="toc-text">3、单源最短路问题——Bellman-Ford算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Floyd-Warshall%E7%AE%97%E6%B3%95"><span class="toc-text">4、多源最短路问题——Floyd-Warshall算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E8%BF%98%E5%8E%9F"><span class="toc-text">5、最短路径还原</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Prim%E7%AE%97%E6%B3%95"><span class="toc-text">6、最小生成树——Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">7、最小生成树——Kruskal算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E2%80%94%E2%80%94Tarjan%E7%AE%97%E6%B3%95"><span class="toc-text">8、强连通分量——Tarjan算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94LCA%EF%BC%88Lowest-Common-Ancestor%EF%BC%89"><span class="toc-text">9、最近公共祖先问题——LCA（Lowest Common Ancestor）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">三、高级数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">1、并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88segment-Tree%EF%BC%89"><span class="toc-text">2、线段树（segment Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89"><span class="toc-text">3、主席树（可持久化线段树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88Binary-Indexed-Tree%EF%BC%89"><span class="toc-text">4、树状数组（Binary Indexed Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81ST%E8%A1%A8"><span class="toc-text">5、ST表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">6、二叉树求先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%89"><span class="toc-text">7、先序中序还原二叉树（整数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94KMP"><span class="toc-text">2、字符串匹配算法——KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Sunday"><span class="toc-text">3、字符串匹配算法——Sunday</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-text">五、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">1、快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-text">2、堆排序实现优先队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%AD%9B%E6%B3%95"><span class="toc-text">七、筛法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%83%E6%B0%8F%EF%BC%88Eratosthenes%EF%BC%89%E7%AD%9B%E6%B3%95"><span class="toc-text">1、埃氏（Eratosthenes）筛法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%88%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%89"><span class="toc-text">2、线性筛（欧拉筛法）</span></a></li></ol></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/LC周赛">
        <div class="categories-list-item">
          LC周赛
          <span class="categories-list-item-badge">11</span>
        </div>
      </a>
    
      <a href="/categories/STL常用模板总结">
        <div class="categories-list-item">
          STL常用模板总结
          <span class="categories-list-item-badge">10</span>
        </div>
      </a>
    
      <a href="/categories/小技巧">
        <div class="categories-list-item">
          小技巧
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/字符串">
        <div class="categories-list-item">
          字符串
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/算法">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\STL" title="STL"><div class="tags-list-item">STL</div></a>
    
    <a href="\tags\算法" title="算法"><div class="tags-list-item">算法</div></a>
    
    <a href="\tags\小技巧" title="小技巧"><div class="tags-list-item">小技巧</div></a>
    
    <a href="\tags\字符串高精度" title="字符串高精度"><div class="tags-list-item">字符串高精度</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">一、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1、背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-01%E8%83%8C%E5%8C%85-gt"><span class="toc-text">&lt;01背包&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-gt"><span class="toc-text">&lt;完全背包&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%9D%E7%A6%BB"><span class="toc-text">2、字符串距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B1%82%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-text">3、求最大连续子序列和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9B%BE%E8%AE%BA"><span class="toc-text">二、图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">1、图的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">2、单源最短路问题——Dijkstra算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Bellman-Ford%E7%AE%97%E6%B3%95"><span class="toc-text">3、单源最短路问题——Bellman-Ford算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Floyd-Warshall%E7%AE%97%E6%B3%95"><span class="toc-text">4、多源最短路问题——Floyd-Warshall算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E8%BF%98%E5%8E%9F"><span class="toc-text">5、最短路径还原</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Prim%E7%AE%97%E6%B3%95"><span class="toc-text">6、最小生成树——Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">7、最小生成树——Kruskal算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E2%80%94%E2%80%94Tarjan%E7%AE%97%E6%B3%95"><span class="toc-text">8、强连通分量——Tarjan算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94LCA%EF%BC%88Lowest-Common-Ancestor%EF%BC%89"><span class="toc-text">9、最近公共祖先问题——LCA（Lowest Common Ancestor）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">三、高级数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">1、并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88segment-Tree%EF%BC%89"><span class="toc-text">2、线段树（segment Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89"><span class="toc-text">3、主席树（可持久化线段树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88Binary-Indexed-Tree%EF%BC%89"><span class="toc-text">4、树状数组（Binary Indexed Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81ST%E8%A1%A8"><span class="toc-text">5、ST表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">6、二叉树求先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%85%88%E5%BA%8F%E4%B8%AD%E5%BA%8F%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%89"><span class="toc-text">7、先序中序还原二叉树（整数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94KMP"><span class="toc-text">2、字符串匹配算法——KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Sunday"><span class="toc-text">3、字符串匹配算法——Sunday</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-text">五、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">1、快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-text">2、堆排序实现优先队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%AD%9B%E6%B3%95"><span class="toc-text">七、筛法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%83%E6%B0%8F%EF%BC%88Eratosthenes%EF%BC%89%E7%AD%9B%E6%B3%95"><span class="toc-text">1、埃氏（Eratosthenes）筛法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%88%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%89"><span class="toc-text">2、线性筛（欧拉筛法）</span></a></li></ol></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-21</div>
        <a href="/2021/03/21/LeetCode第233场周赛/"><div class="recent-posts-item-content">LeetCode第233场周赛</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-14</div>
        <a href="/2021/03/14/LeetCode第232场周赛/"><div class="recent-posts-item-content">LeetCode第232场周赛</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-07</div>
        <a href="/2021/03/07/c++位运算函数之-__builtin_/"><div class="recent-posts-item-content">c++位运算函数之（__builtin_）</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-06</div>
        <a href="/2021/03/06/LeetCode第47场双周赛/"><div class="recent-posts-item-content">LeetCode第47场双周赛</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2021
        </span>
        <a href="/" class="footer-link">Monologue's blog </a>
      </div>
    </div>

    
    <div class="footer-dsc">
      
      
      Powered by
      <a href="https://hexo.io/" class="footer-link" target="_blank" rel="nofollow noopener noreferrer">&nbsp;Hexo </a>
      
      
      <span>&nbsp;|&nbsp;</span>
      
      
      
      Theme -
      <a href="https://github.com/theme-kaze" class="footer-link" target="_blank"
        rel="nofollow noopener noreferrer">&nbsp;Kaze</a>
      
    </div>
    
    
    
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton" >
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget">
  <i class="iconfont icon-weather button-icon"></i>
</a>

  
  
  

  
  
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
      };
    </script>
    
<script src="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js"></script>

  

  
  
  
  
<script src="/js/main.js"></script>

  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>