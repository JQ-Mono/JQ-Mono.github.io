<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://jq-mono.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jq-mono.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-LeetCode第225场周赛" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/24/LeetCode%E7%AC%AC225%E5%9C%BA%E5%91%A8%E8%B5%9B/" class="article-date">
  <time class="dt-published" datetime="2021-01-23T16:00:00.000Z" itemprop="datePublished">2021-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LC%E5%91%A8%E8%B5%9B/">LC周赛</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/24/LeetCode%E7%AC%AC225%E5%9C%BA%E5%91%A8%E8%B5%9B/">LeetCode第225场周赛</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1738-找出第-K-大的异或坐标值"><a href="#1738-找出第-K-大的异或坐标值" class="headerlink" title="1738. 找出第 K 大的异或坐标值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/">1738. 找出第 K 大的异或坐标值</a></h4><p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p>
<p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code>（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>
<p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（**<code>k</code> 的值从 1 开始计数**）。</p>
<p><strong>示例 1：</strong></p>
<pre class="language-none"><code class="language-none">输入：matrix &#x3D; [[5,2],[1,6]], k &#x3D; 1
输出：7
解释：坐标 (0,1) 的值是 5 XOR 2 &#x3D; 7 ，为最大的值。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="language-none"><code class="language-none">输入：matrix &#x3D; [[5,2],[1,6]], k &#x3D; 2
输出：5
解释：坐标 (0,0) 的值是 5 &#x3D; 5 ，为第 2 大的值。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="language-none"><code class="language-none">输入：matrix &#x3D; [[5,2],[1,6]], k &#x3D; 3
输出：4
解释：坐标 (1,0) 的值是 5 XOR 1 &#x3D; 4 ，为第 3 大的值。</code></pre>

<p><strong>示例 4：</strong></p>
<pre class="language-none"><code class="language-none">输入：matrix &#x3D; [[5,2],[1,6]], k &#x3D; 4
输出：0
解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 &#x3D; 0 ，为第 4 大的值。</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 1000</code></li>
<li><code>0 &lt;= matrix[i][j] &lt;= 106</code></li>
<li><code>1 &lt;= k &lt;= m * n</code></li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>二维异或前缀和</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">kthLargestValue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^=</span> matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> vec<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>



<h4 id="1739-放置盒子"><a href="#1739-放置盒子" class="headerlink" title="1739. 放置盒子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/building-boxes/">1739. 放置盒子</a></h4><p>有一个立方体房间，其长度、宽度和高度都等于 <code>n</code> 个单位。请你在房间里放置 <code>n</code> 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：</p>
<ul>
<li>你可以把盒子放在地板上的任何地方。</li>
<li>如果盒子 <code>x</code> 需要放置在盒子 <code>y</code> 的顶部，那么盒子 <code>y</code> 竖直的四个侧面都 <strong>必须</strong> 与另一个盒子或墙相邻。</li>
</ul>
<p>给你一个整数 <code>n</code> ，返回接触地面的盒子的 <strong>最少</strong> 可能数量<em>。</em></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/3-boxes.png" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：n &#x3D; 3
输出：3
解释：上图是 3 个盒子的摆放位置。
这些盒子放在房间的一角，对应左侧位置。</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/4-boxes.png" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：n &#x3D; 4
输出：3
解释：上图是 3 个盒子的摆放位置。
这些盒子放在房间的一角，对应左侧位置。</code></pre>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/10-boxes.png" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：n &#x3D; 10
输出：6
解释：上图是 10 个盒子的摆放位置。
这些盒子放在房间的一角，对应后方位置。</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 109</code></li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li><p>三维尽可能放满，多出来的方块通过下个维度计算</p>
</li>
<li><p>高度为$high$的最多堆叠方块数为：</p>
<p>$$\frac{high\times(high+1)\times(high+2)}{6}$$</p>
</li>
<li><p>占用底面积为：</p>
<p>$$\frac{high\times(high+1)}{2}$$</p>
</li>
<li><p>二维尽可能放满，多出来的方块通过下个维度计算</p>
</li>
<li><p>高度为$high$的最多堆叠方块数为：</p>
<p>$$\frac{high\times(high+1)}{2}$$</p>
</li>
<li><p>占用底面积为：</p>
<p>$$high$$</p>
</li>
<li><p>一维的话，看是否剩余方块，若有剩余，答案加1。</p>
</li>
<li><p>三维表示整个立体每层尽可能放满</p>
</li>
<li><p>二维表示三维放满后最靠外侧的三角斜面（离墙最远的那个斜面）</p>
</li>
<li><p>一维表示二维三角斜面的边（立起来的边）</p>
</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minimumBoxes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> high <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> left <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 立体维度</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">6</span> <span class="token operator">&lt;=</span> left<span class="token punctuation">)</span> high<span class="token operator">++</span><span class="token punctuation">;</span>
        ans <span class="token operator">+=</span> high <span class="token operator">*</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        left <span class="token operator">-=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> high <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
        <span class="token comment">// 平面维度</span>
        high <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> left<span class="token punctuation">)</span> high<span class="token operator">++</span><span class="token punctuation">;</span>
        ans <span class="token operator">+=</span> high<span class="token punctuation">;</span>
        left <span class="token operator">-=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> high <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
        <span class="token comment">// 线维度</span>
        <span class="token keyword">return</span> ans <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2021/01/24/LeetCode%E7%AC%AC225%E5%9C%BA%E5%91%A8%E8%B5%9B/" data-id="ckmm2kgjr0002649vas6scmzu" data-title="LeetCode第225场周赛" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LeetCode第224场周赛" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/17/LeetCode%E7%AC%AC224%E5%9C%BA%E5%91%A8%E8%B5%9B/" class="article-date">
  <time class="dt-published" datetime="2021-01-16T16:00:00.000Z" itemprop="datePublished">2021-01-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LC%E5%91%A8%E8%B5%9B/">LC周赛</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/17/LeetCode%E7%AC%AC224%E5%9C%BA%E5%91%A8%E8%B5%9B/">LeetCode第224场周赛</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1727-重新排列后的最大子矩阵"><a href="#1727-重新排列后的最大子矩阵" class="headerlink" title="1727. 重新排列后的最大子矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/">1727. 重新排列后的最大子矩阵</a></h4><p>给你一个二进制矩阵 <code>matrix</code> ，它的大小为 <code>m x n</code> ，你可以将 <code>matrix</code> 中的 <strong>列</strong> 按任意顺序重新排列。</p>
<p>请你返回最优方案下将 <code>matrix</code> 重新排列后，全是 <code>1</code> 的子矩阵面积。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/screenshot-2020-12-30-at-40536-pm.png" alt="img"></strong></p>
<pre class="language-none"><code class="language-none">输入：matrix &#x3D; [[0,0,1],[1,1,1],[1,0,1]]
输出：4
解释：你可以按照上图方式重新排列矩阵的每一列。
最大的全 1 子矩阵是上图中加粗的部分，面积为 4 。</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/screenshot-2020-12-30-at-40852-pm.png" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：matrix &#x3D; [[1,0,1,0,1]]
输出：3
解释：你可以按照上图方式重新排列矩阵的每一列。
最大的全 1 子矩阵是上图中加粗的部分，面积为 3 。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="language-none"><code class="language-none">输入：matrix &#x3D; [[1,1,0],[1,0,1]]
输出：2
解释：由于你只能整列整列重新排布，所以没有比面积为 2 更大的全 1 子矩形。</code></pre>

<p><strong>示例 4：</strong></p>
<pre class="language-none"><code class="language-none">输入：matrix &#x3D; [[0,0],[0,0]]
输出：0
解释：由于矩阵中没有 1 ，没有任何全 1 的子矩阵，所以面积为 0 。</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m * n &lt;= 105</code></li>
<li><code>matrix[i][j]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">largestSubmatrix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> mat<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> mat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> mat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> mat<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">sort</span><span class="token punctuation">(</span>mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2021/01/17/LeetCode%E7%AC%AC224%E5%9C%BA%E5%91%A8%E8%B5%9B/" data-id="ckmm2kgjk0001649v7x9p6g7i" data-title="LeetCode第224场周赛" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-经典基础算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/10/%E7%BB%8F%E5%85%B8%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-10-09T16:00:00.000Z" itemprop="datePublished">2020-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/10/%E7%BB%8F%E5%85%B8%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">经典基础算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、动态规划"><a href="#一、动态规划" class="headerlink" title="一、动态规划"></a>一、动态规划</h2><h3 id="1、背包问题"><a href="#1、背包问题" class="headerlink" title="1、背包问题"></a>1、背包问题</h3><h4 id="lt-01背包-gt"><a href="#lt-01背包-gt" class="headerlink" title="&lt;01背包&gt;"></a>&lt;01背包&gt;</h4><ul>
<li><font size=4 color=blue>N个物品，物品i具有体积vi、价值pi，现有一容量为V的背包，问背包能装的物品的价值的最大值</font></li>
<li><font size=4 color=red>若定义一个二维数组dp[i][j]，表示前i个物品在只提供j容量大小时物品的最大值。</font><ul>
<li>递推式：<font size=4>dp[i][j] = max { dp[i - 1][j] , dp[i – 1][j – weight[i]] + val[i] }</font></li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(int j &#x3D; 0; j &lt;&#x3D; V; ++j) &#x2F;&#x2F; 初始化，拿0个物品的价值为0
    dp[0][j] &#x3D; 0;
for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)
    for (int j &#x3D; 0; j &lt;&#x3D; V; ++j)
        if (j &lt; weight[i])
            dp[i][j] &#x3D; dp[i - 1][j];
		else
            dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + val[i]);</code></pre>

<ul>
<li><font size=4 color=red><strong>二维数组中用下一行的话之前的几行就没有用了！</strong>所以，为了节省内存，我们用一维数组来维护每一行的数据，并更新。（滚动数组）</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">memset(dp, 0, sizeof dp);
for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)
    for(int j &#x3D; V; j &gt;&#x3D; weight[i]; --j)
        dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + val[i]);</code></pre>

<ul>
<li>举例：n=4、(weight , val) = {(2 , 3) , (1 , 2) , (3 , 4) , (2 , 2)}、V=5</li>
</ul>
<table>
<thead>
<tr>
<th align="center">i\j</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
</tr>
</tbody></table>
<ul>
<li><p>dp[3][4] = max(dp[2][4] , dp[2][1] + 4) 、dp[3][1] = max(dp[3][1] , dp[2][1])</p>
</li>
<li><p><font size=4 color=red>若要求恰s好放满背包：</font></p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define INF -2e9
dp[0][0] &#x3D; 0;
for(int j &#x3D; 1; j &lt;&#x3D; V; ++j) &#x2F;&#x2F; 初始化拿0个物品的价值为0
    dp[0][j] &#x3D; INF; &#x2F;&#x2F; ？？？
&#x2F;&#x2F;空间优化后
dp[0] &#x3D; 0;
for(int i &#x3D; 1; i &lt;&#x3D; V; ++i)
    dp[i] &#x3D; INF;</code></pre>

<h4 id="lt-完全背包-gt"><a href="#lt-完全背包-gt" class="headerlink" title="&lt;完全背包&gt;"></a>&lt;完全背包&gt;</h4><ul>
<li><font size=4 color=blue>上述问题中物品数量改为无穷个，即为完全背包问题</font></li>
</ul>
<h3 id="2、字符串距离"><a href="#2、字符串距离" class="headerlink" title="2、字符串距离"></a>2、字符串距离</h3><ul>
<li><font size = 4>状态转移表达式如下：</font></li>
</ul>
<p>$$<br>Lev_{a,b}(i,j)=<br>\begin{cases}<br>i&amp;,j=0 \<br>j&amp;,i=0 \<br>min<br>\begin{cases}<br>Lev_{a,b}(i,j-1)+1\<br>Lev_{a,b}(i-1,j)+1\<br>Lev_{a,b}(i-1,j-1)+1<br>\end{cases}<br>&amp;, other<br>\end{cases}<br>$$</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 时间复杂度为O(MN)，空间复杂度为O(MN)
int getDistence(string a, string b)&#123; &#x2F;&#x2F; 计算字符串a、b的距离
    int dp[M][M]; &#x2F;&#x2F; dp[i][j]表示a的前i个字符与b的前j个字符，两字符串的距离
    int alen &#x3D; a.size(), blen &#x3D; b.size();
    clr(dp);
    for(int i &#x3D; 1; i &lt;&#x3D; alen; ++i)&#123; &#x2F;&#x2F; 初始化边界
        dp[i][0]&#x3D;i;
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; blen; ++i)&#123; &#x2F;&#x2F; 初始化边界
        dp[0][i]&#x3D;i;
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; alen; ++i)&#123;
        for(int j &#x3D; 1; j &lt;&#x3D; blen; ++j)&#123;
            if(a[i-1] &#x3D;&#x3D; b[j-1])
                dp[i][j] &#x3D; dp[i-1][j-1];
            else
                dp[i][j] &#x3D; min(dp[i][j-1], min(dp[i-1][j-1], dp[i-1][j])) + 1;
        &#125;
    &#125;
    return dp[alen][blen];
&#125;
&#x2F;&#x2F; 可用一维滚动数组将空间复杂度降为O(max&#123;M,N&#125;)（以下摘自网络，尚未分析）
int dp[1010];
void work() &#123;
	for(int j&#x3D;1; j&lt;&#x3D;lenb; j++) dp[j] &#x3D; j;
	int t1, t2;
	for(int i&#x3D;1; i&lt;&#x3D;lena; i++) &#123;
		t1 &#x3D; dp[0]++;
		for(int j&#x3D;1; j&lt;&#x3D;lenb; j++) &#123;
			t2 &#x3D; dp[j];
			if(a[i-1]&#x3D;&#x3D;b[j-1])
                dp[j] &#x3D; t1;
            else
                dp[j] &#x3D; min(t1, min(dp[j-1], dp[j]))+1;
            t1 &#x3D; t2;
        &#125;
    &#125;
    printf(&quot;%d\n&quot;, dp[lenb]);
&#125;</code></pre>

<h3 id="3、求最大连续子序列和"><a href="#3、求最大连续子序列和" class="headerlink" title="3、求最大连续子序列和"></a>3、求最大连续子序列和</h3><ul>
<li><font size = 4 color = blue>状态转移方程：sum[i] = max{sum[i-1]+a[i],a[i]}</font></li>
<li><font size = 4 color = blue>sum[i]记录以a[i]为子序列末端的最大连续子序列和</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">int MaxSum(int n)&#123;
    int sum &#x3D; 0,b &#x3D; 0;
    for(int i &#x3D; 0; i &lt; n; i++)&#123;
        if(b &gt; 0) b +&#x3D; a[i];
        else b &#x3D; a[i];
        if(b &gt; sum) sum &#x3D; b;
    &#125;
    return sum;
&#125;</code></pre>



<h2 id="二、图论"><a href="#二、图论" class="headerlink" title="二、图论"></a>二、图论</h2><h3 id="1、图的表示"><a href="#1、图的表示" class="headerlink" title="1、图的表示"></a>1、图的表示</h3><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;* 邻接矩阵：g[i][j]表示编号i的点到编号j的点这段路的权值 *&#x2F;
&#x2F;* 对于无权图，可以将矩阵定义为bool类型，判断两点之间是否有边 *&#x2F;
&#x2F;* 对于有权图，可以令不直接相连的两点i、j：g[i][j]&#x3D;INF，区分于权值为0的边 *&#x2F;
#define INF 0x3fffffff
#define M 1010
bool g1[M][M];
int g2[M][M];
&#x2F;* 邻接表,定义不再赘述 *&#x2F;
#include&lt;vector&gt;
vector&lt;int&gt; g[M];
int main()&#123;
    int n,m; &#x2F;&#x2F; n个点，m条边
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 0; i &lt; m; ++i)&#123;
        int s,t;
        cin&gt;&gt;s&gt;&gt;t;
        g[s].push_back(t);
    &#125;
    &#x2F;* 图的操作 *&#x2F;
    return 0;
&#125;
&#x2F;* 边上有属性的情况 *&#x2F;
class edge&#123;
public:
    edge(int e,int l):end(e),len(l)&#123;&#125;
    int end;
    int len;
&#125;;
&#x2F;&#x2F; typedef pair&lt;int,int&gt; edge; first是最短距离，second是终顶点的编号
vector&lt;edge&gt; g[M];</code></pre>

<h3 id="2、单源最短路问题——Dijkstra算法"><a href="#2、单源最短路问题——Dijkstra算法" class="headerlink" title="2、单源最短路问题——Dijkstra算法"></a>2、单源最短路问题——Dijkstra算法</h3><ul>
<li><p><font size=4 color=red>每轮松弛后在dis数组（保存着每个点到源点的最短距离）中挑出未标记的最小值，并标记这个点，再将这个点作为新一轮松弛的起点，直至所有点都被标记</font></p>
</li>
<li><p><font size=4 color=blue>邻接矩阵，复杂度为O(n^2^)</font></p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define INF 0x7fffffff
#define M 1010
int map[M][M],dis[M]; &#x2F;&#x2F; map保存图，dis保存源点到其他每个点的最短距离
int n,e,start,end;
bool flag[M];
void dijkstra(int s)&#123; &#x2F;&#x2F; s为源点
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;
        &#x2F;* 初始化：每个点均未被确认答案，每个点到源点距离为无穷大 *&#x2F;
		flag[i]&#x3D;true;
		dis[i]&#x3D;INF;
	&#125;
    &#x2F;* 初始松弛，修改与源点有边的点的最短距离 *&#x2F;
	flag[s] &#x3D; false;
	for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)
		if(dis[i] &gt; map[s][i])
			dis[i] &#x3D; map[s][i];
    &#x2F;* 剩下n-1轮松弛，每次从dis中挑出最小且未确定的点，对其他所有点进行松弛 *&#x2F;
	for(int i &#x3D; 1; i &lt; n; ++i)&#123;
		int bestPoint,min&#x3D;INF;
		for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)
			if(flag[j] &amp;&amp; dis[j] &lt; min)
				min &#x3D; dis[j];
				bestPoint &#x3D; j;
			&#125;
		&#125;
		flag[bestPoint]&#x3D;false; &#x2F;&#x2F; 标记已访问的点
		for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)
			if(dis[j] &gt; dis[bestPoint]+map[bestPoint][j])
				dis[j] &#x3D; dis[bestPoint]+map[bestPoint][j];
	&#125;
&#125;</code></pre>

<ul>
<li><font size=4 color=blue>邻接表，用优先队列能以O(logn)复杂度选取每轮的最短距离，优化到O(Mlogn)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#define M 200010
#define INF 0x7fffffff
using namespace std;
class edge&#123;
public:
    edge(int e,int l):end(e),len(l)&#123;&#125;
    int end;
    int len;
&#125;;
bool operator &gt; (const edge&amp; e1,const edge&amp; e2)&#123;
	return e1.len &gt; e2.len; &#x2F;&#x2F; 用于优先队列中的比较
&#125;
int n,m,dis[M];
vector&lt;edge&gt; g[M]; &#x2F;&#x2F; 图的保存

void dijkstra(int s)&#123;
	priority_queue&lt;edge, vector&lt;edge&gt;, greater&lt;edge&gt; &gt; q;
	for(int i &#x3D; 0; i &lt;&#x3D; n; ++i) dis[i]&#x3D;INF; &#x2F;&#x2F; 初始化到源点最短距离
	dis[s] &#x3D; 0; &#x2F;&#x2F; 源点到源点距离为0
	q.push(edge(s,0)); &#x2F;&#x2F; 优先队列中初始化一个源点
	while(q.size())&#123;
		edge e &#x3D; q.top();
		q.pop();
		int newStart &#x3D; e.end;
		if(dis[newStart] &lt; e.len) continue; &#x2F;&#x2F; 相当于删掉已经被松弛却还没从优先队列中删掉的边
		for(int i &#x3D; 0; i &lt; g[newStart].size(); ++i)&#123;
			edge evEdge &#x3D; g[newStart][i]; &#x2F;&#x2F; 枚举每个从newStart开始的边
            &#x2F;* 判断是否可以松弛，可以的话就把松弛后的边加入优先队列 *&#x2F;
			if(dis[evEdge.end] &gt; dis[newStart] + evEdge.len)&#123;
				dis[evEdge.end] &#x3D; dis[newStart] + evEdge.len;
				q.push( edge(evEdge.end,dis[evEdge.end]) );
			&#125;
		&#125;
	&#125;
&#125;
&#x2F;* 使用实例：输入顶点数、边数、源点编号，以及每条边的属性，按顺序输出每个点到源点的最短距离 *&#x2F;
int main()&#123;
	int s;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i&#x3D;0;i&lt;m;++i)&#123;
		int start,end,len;
		cin&gt;&gt;start&gt;&gt;end&gt;&gt;len;
		g[start].push_back(edge(end,len));
	&#125;
	dijkstra(s);
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)cout&lt;&lt;dis[i]&lt;&lt;&#39; &#39;;
	return 0;
&#125;</code></pre>

<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 2020.11.13 重写
#include&lt;bits&#x2F;stdc++.h&gt;
#define M 200010
#define INF 0x7fffffff
using namespace std;

int n,m,dis[M];
vector&lt;pair&lt;int, int&gt;&gt; g[M]; &#x2F;&#x2F; 图的保存

void dijkstra(int s)&#123;
	priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q;
	for(int i &#x3D; 0; i &lt;&#x3D; n; ++i) dis[i] &#x3D; INF; &#x2F;&#x2F; 初始化到源点最短距离
	dis[s] &#x3D; 0; &#x2F;&#x2F; 源点到源点距离为0
	q.push(&#123;0, s&#125;); &#x2F;&#x2F; 优先队列中初始化一个源点
	while(q.size())&#123;
		auto e &#x3D; q.top(); q.pop();
		int ns &#x3D; e.second;
		if(dis[ns] &lt; e.first) continue; &#x2F;&#x2F; 删掉已经被松弛却还没从优先队列中删掉的边
		for(int i &#x3D; 0; i &lt; g[ns].size(); ++i)&#123;
			auto ev &#x3D; g[ns][i]; &#x2F;&#x2F; 枚举每个从newStart开始的边
            &#x2F;* 判断是否可以松弛，可以的话就把松弛后的边加入优先队列 *&#x2F;
			if(dis[ev.second] &gt; dis[ns] + ev.first)&#123;
				dis[ev.second] &#x3D; dis[ns] + ev.first;
				q.push(&#123;dis[ev.second], ev.second&#125;);
			&#125;
		&#125;
	&#125;
&#125;
int main()&#123;
	int s;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i &#x3D; 0; i &lt; m; ++i)&#123;
		int start,end,len;
		cin&gt;&gt;start&gt;&gt;end&gt;&gt;len;
		g[start].push_back(&#123;len, end&#125;);
	&#125;
	dijkstra(s);
	for(int i &#x3D; 1; i &lt;&#x3D; n; ++i) cout&lt;&lt;dis[i]&lt;&lt;&#39; &#39;;
	return 0;
&#125;</code></pre>



<h3 id="3、单源最短路问题——Bellman-Ford算法"><a href="#3、单源最短路问题——Bellman-Ford算法" class="headerlink" title="3、单源最短路问题——Bellman-Ford算法"></a>3、单源最短路问题——Bellman-Ford算法</h3><ul>
<li><font size=4 color=blue>Bellman-Ford算法的时间复杂度是O(MN)，高于Dijkstra算法，但是可以处理存在负边的情况</font></li>
<li><font size=4>使用队列优化可以稍微降低其复杂度，而且队列优化后的算法还有个另外的名字：SPFA（Shortest Path Faster Algorithm），可以比较好的适用于随机图。但是一旦数据有特殊，可以将这个算法卡回O(MN)，有时会导致超时。</font></li>
<li><font size=4>因此在没有负权的情况下还是用Dijkstra算法好一些</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define M 200010
#define INF 0x7fffffff
class edge&#123;
public:
    edge(int s,int e,int l):start(s),end(e),len(l)&#123;&#125;
    int start;
    int end;
    int len;
&#125;;
int n,m,dis[M]; &#x2F;&#x2F; n个点，m条边，dis保存最短距离
edge edges[Max_E]; &#x2F;&#x2F; 保存所有的边
&#x2F;* 算法可以判断图中是否有负环，如需做此判断，需要进行n次循环才行 *&#x2F;
bool Bellman-Ford(int s)&#123;
    for(int i &#x3D; 0; i &lt; n; ++i)dis[i] &#x3D; INF;
    dis[s] &#x3D; 0;
    for(int i &#x3D; 0; i &lt; n; ++i)&#123;
        for(int j &#x3D; 0; j &lt; m; ++j)&#123;
            edge evEdge &#x3D; edges[j];
            if(dis[evEdge.end] &gt; dis[evEdge.start] + evEdge.len)&#123;
                dis[evEdge.end] &#x3D; dis[evEdge.start] + evEdge.len;
                if(i &#x3D;&#x3D; n-1) return false; &#x2F;&#x2F; 若第n轮仍有松弛，则存在负环
            &#125;
        &#125;
    &#125;
    return true;
&#125;
&#x2F;* 如果不用判断是否有负环，则无需进行n-1次循环，可以稍加优化时间效率 *&#x2F;
void Bellman-Ford(int s)&#123;
    for(int i &#x3D; 0; i &lt; n; ++i)dis[i] &#x3D; INF;
    dis[s] &#x3D; 0;
    while(true)&#123;
        bool update &#x3D; false; &#x2F;&#x2F; 循环至不再更新就可以停下
        for(int i &#x3D; 0; i &lt; m; ++i)&#123;
            edge evEdge &#x3D; edges[i];
            if(dis[evEdge.start] &#x3D;&#x3D; INF) continue; &#x2F;&#x2F; 还未松弛到某边的起点时，暂时略过
            if(dis[evEdge.end] &gt; dis[evEdge.start]+evEdge.len)&#123;
                dis[evEdge.end] &#x3D; dis[evEdge.start]+evEdge.len;
                update &#x3D; true;
            &#125;
        &#125;
        if(!update) break;
    &#125;
&#125;
&#x2F;* 若图是不存在环的，那么可以按拓扑序给顶点编号，按序松弛，此时效率最优 *&#x2F;</code></pre>



<h3 id="4、多源最短路问题——Floyd-Warshall算法"><a href="#4、多源最短路问题——Floyd-Warshall算法" class="headerlink" title="4、多源最短路问题——Floyd-Warshall算法"></a>4、多源最短路问题——Floyd-Warshall算法</h3><ul>
<li><font size=4 color=blue>用于解决多源最短路径问题的算法</font></li>
<li><font size=4 color=blue>时间复杂度为O（n^3^）</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;Floyd算法（关键部分）
&#x2F;&#x2F;e[i][j]表示由i到j的路径长度
for(int k &#x3D; 0; k &lt; n; ++k)&#123;
	for(int i &#x3D; 0; i &lt; n; ++i)
		for(int j &#x3D; 0; j &lt; n; ++j)
			if(map[i][j] &gt; map[i][k] + map[k][j])
				map[i][j] &#x3D; map[i][k] + map[k][j];
&#125;
&#x2F;* 也可以判断是否有负环，但是有些大材小用 *&#x2F;
for(int i&#x3D;0;i&lt;n;++i)
    if(map[i][i] &lt; 0)
        flag &#x3D; false; &#x2F;&#x2F; 表示出现了负环
	&#125;
&#125;</code></pre>



<h3 id="5、最短路径还原"><a href="#5、最短路径还原" class="headerlink" title="5、最短路径还原"></a>5、最短路径还原</h3><ul>
<li><font size=4>该方法适用于以上最短路算法</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">int prev[M]; &#x2F;&#x2F; prev[i]表示最短路上顶点i的前驱，用于路径还原
&#x2F;* 在每次松弛的时候更新prev数组即可 *&#x2F;
&#x2F;* 还原时，不断把j替换成prev[j]直到j&#x3D;s为止 *&#x2F;</code></pre>



<h3 id="6、最小生成树——Prim算法"><a href="#6、最小生成树——Prim算法" class="headerlink" title="6、最小生成树——Prim算法"></a>6、最小生成树——Prim算法</h3><ul>
<li><font size=4 color=blue>假设一颗只包含一个顶点v的树T。然后贪心地选取T和其他顶点之间相连的最小权值的边，并把它加到T中。处理过程与Dijkstra算法相似</font></li>
<li><font size=4>在不优化的情况下，时间复杂度是O(N^2^)，代码写起来也稍微复杂些</font></li>
<li><del>（真不知道这个算法的意义在哪）</del></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">int cost[M][M]; &#x2F;&#x2F; cost[i][j]表示边(i,j)的权值，不存在的情况下设为INF
int mincost[M]; &#x2F;&#x2F; 从集合T出发到每个顶点的最小权值
bool used[M]; &#x2F;&#x2F; 顶点i是否包含在集合T中
int n;
int prim()&#123;
    for(int i &#x3D; 0; i &lt; n; ++i)&#123;
        mincost[i] &#x3D; INF;
        used[i] &#x3D; false;
    &#125;
    mincost[0] &#x3D; 0; &#x2F;&#x2F; 默认T初始化为只有编号为0这一个顶点
    int ans &#x3D; 0; &#x2F;&#x2F; 最小生成树的总权值
    while(true)&#123;
        int v &#x3D; -1; &#x2F;&#x2F; 挑出在集合T外、T到其权值最小的顶点
        for(int i &#x3D; 0; i &lt; n; ++i)
            if(!used[i] &amp;&amp; (v &#x3D;&#x3D; -1 || mincost[i] &lt; mincost[v])) v &#x3D; i;
        if(v &#x3D;&#x3D; -1) break; &#x2F;&#x2F; 所有点都已经被加入T集合
        used[v] &#x3D; true; &#x2F;&#x2F; 加入T集合
        ans +&#x3D; mincost[v];
        for(int i &#x3D; 0; i &lt; n; ++i)&#123;
            mincost[i] &#x3D; min(mincost[i],cost[v][i]); &#x2F;&#x2F; 用新加入的点松弛其他所有点
        &#125;
    &#125;
    return ans;
&#125;</code></pre>



<h3 id="7、最小生成树——Kruskal算法"><a href="#7、最小生成树——Kruskal算法" class="headerlink" title="7、最小生成树——Kruskal算法"></a>7、最小生成树——Kruskal算法</h3><ul>
<li><font size=4 color=blue>对边从小到大排序，用并查集维护连通分量，依次添加权值最小且不在同一个连通分量的边</font></li>
<li><font size=4>时间复杂度是O(MlogN)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define M 200010
class edge&#123;
public:
    edge(int s,int e,int l):start(s),end(e),len(l)&#123;&#125;
    int start;
    int end;
    int len;
&#125;;
bool cmp(const edge&amp; e1,const edge&amp; e2)&#123;
    return e1.len &lt; e2.len;
&#125;
int f[M]; &#x2F;&#x2F; 并查集
edge edges[M]; &#x2F;&#x2F; 边集
int n,m;
int find(int x)&#123;return f[x]&#x3D;&#x3D;x?x:f[x]&#x3D;find(f[x]);&#125;
int Kruskal()&#123;
    sort(edges,edges+m,cmp);
    for(int i &#x3D; 0; i &lt;&#x3D; n; ++i) f[i] &#x3D; i; &#x2F;&#x2F; 初始化并查集
    int ans &#x3D; 0;
    for(int i &#x3D; 0; i &lt; m; ++i)&#123;
        edge evEdge &#x3D; edges[i];
        if(find(evEdge.start) !&#x3D; find(evEdge.end))&#123;
            ans +&#x3D; evEdge.len;
            f[find(evEdge.start)] &#x3D; find(evEdge.end); &#x2F;&#x2F; 合并两分量
        &#125;
    &#125;
    return ans;
&#125;
&#x2F;&#x2F; 或堆排序维护优先队列（课设D2题）</code></pre>



<h3 id="8、强连通分量——Tarjan算法"><a href="#8、强连通分量——Tarjan算法" class="headerlink" title="8、强连通分量——Tarjan算法"></a>8、强连通分量——Tarjan算法</h3><ul>
<li><font size=4 color=blue>时间复杂度为O(N+M)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#define M 10010
using namespace std;
int dfn[M],low[M]; &#x2F;&#x2F; dfn保存每个点的时间戳编号，low是某个点或其子树能够追溯到最早的栈中结点编号
int Bcnt,index,stack[M],top; &#x2F;&#x2F; Bcnt记录强连通分量个数，index是时间戳，top是栈顶编号
bool instack[M]; &#x2F;&#x2F; 判断某个点是否在栈内
vector&lt;int&gt; g[M]; &#x2F;&#x2F; 邻接表保存图
void tarjan(int i)&#123;
	int j;
	dfn[i] &#x3D; low[i] &#x3D; ++index; &#x2F;&#x2F; dfn、low初始化为时间戳
	instack[i] &#x3D; true; &#x2F;&#x2F; i入栈，作为一颗（子）dfs树的根
	stack[++top] &#x3D; i;
	for(int k &#x3D; 0; k &lt; g[i].size(); ++k)&#123; &#x2F;&#x2F; 访问以i为起点的所有边
		j &#x3D; g[i][k]; &#x2F;&#x2F; j记录以i为起点的某条边的终点
		if(!dfn[j])&#123; &#x2F;&#x2F; 若这个点还没被访问，就递归调用函数，压栈
			tarjan(j);
			if(low[j] &lt; low[i]) low[i] &#x3D; low[j]; &#x2F;&#x2F; 若j的根被放小，则把j的根i也放小
		&#125;
        &#x2F;* 或者j这个点已被访问但是j在栈中，且j的时间戳早于i，将i的low放小 *&#x2F;
		else if(instack[j] &amp;&amp; dfn[j] &lt; low[i]) low[i] &#x3D; dfn[j];
	&#125;
	if(dfn[i] &#x3D;&#x3D; low[i])&#123; &#x2F;&#x2F; i这个点未被放小，则以i为根的一颗dfs子树是一个强连通分量
		Bcnt++;
        &#x2F;* 弹栈至i被弹出 *&#x2F;
		do&#123;
			j &#x3D; stack[top--];
			instack[j] &#x3D; false;
		&#125;while(j !&#x3D; i);
	&#125;
&#125;
&#x2F;* 使用样例：输入点、边数和所有边，输出强连通分量个数 *&#x2F;
int main()
&#123;
	int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i &#x3D; 0; i &lt; m; ++i)&#123;
        int s,t;
        cin&gt;&gt;s&gt;&gt;t;
        g[s].push_back(t);
    &#125;
    for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;
    	if(!dfn[i])tarjan(i);
	&#125;
	cout&lt;&lt;Bcnt;
	return 0;
&#125;</code></pre>



<h3 id="9、最近公共祖先问题——LCA（Lowest-Common-Ancestor）"><a href="#9、最近公共祖先问题——LCA（Lowest-Common-Ancestor）" class="headerlink" title="9、最近公共祖先问题——LCA（Lowest Common Ancestor）"></a>9、最近公共祖先问题——LCA（Lowest Common Ancestor）</h3><ul>
<li><font size=4 color=blue>朴素做法是，让两个点（若不在同一层，先爬到同一层）一起往上爬，直至相遇。利用倍增提高效率，每次向上爬的高度不是1，而是2的幂</font></li>
<li><font size=4 color=blue>用f[i][j]表示从结点i向上爬2^j^的高度所到达的结点，则f[i][0]就表示结点i的父结点</font></li>
<li><font size=4>顶点编号从1开始</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#define N 500010 &#x2F;&#x2F; 顶点个数
#define LogN 20
using namespace std;
vector&lt;int&gt; g[N];
int f[N][LogN];
int dep[N],lg[N]; &#x2F;&#x2F; lg预处理log_2(n)的值
int n,m,root;
void dfs(int x,int p,int d)&#123; &#x2F;&#x2F;当前点的编号为x，深度为d，其父结点编号为p（-1表示无父结点）
	f[x][0] &#x3D; p; &#x2F;&#x2F; 向上爬1层是父结点
	dep[x] &#x3D; d; &#x2F;&#x2F; 记录深度
	for(int i &#x3D; 0; i &lt; g[x].size(); ++i)&#123;
        &#x2F;* 在判断不是自环的情况下，递归记录更深的结点 *&#x2F;
		if(g[x][i] !&#x3D; p) dfs(g[x][i], x, d+1);
	&#125;
&#125;
void init()&#123; &#x2F;&#x2F; 预处理函数，包括所有必要的处理
	dfs(root,-1,0); &#x2F;&#x2F; 
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)
		lg[i] &#x3D; lg[i-1] + (1 &lt;&lt; lg[i-1]+1 &#x3D;&#x3D; i); &#x2F;&#x2F; 预处理log_2(n)的值
	for(int k &#x3D; 0; k+1 &lt; LogN; ++k)&#123;
		for(int x &#x3D; 1; x &lt;&#x3D; n; ++x)&#123;
			if(f[x][k] &lt; 0) f[x][k+1] &#x3D; -1; &#x2F;&#x2F; 爬2的k次幂已经超过根了，那么k+1次幂也超过了
			else f[x][k+1] &#x3D; f[f[x][k]][k]; &#x2F;&#x2F; 爬2的k+1次幂相当于爬两次k次幂
		&#125;
	&#125;
&#125; 
int LCA(int x,int y)&#123;
	if(dep[x] &lt; dep[y]) x^&#x3D;y^&#x3D;x^&#x3D;y; &#x2F;&#x2F; 交换x、y，使得x的深度更深
	while(dep[x] &gt; dep[y]) x &#x3D; f[x][lg[dep[x]-dep[y]]]; &#x2F;&#x2F; x向上爬直至和y同层
	if(x&#x3D;&#x3D;y) return x; &#x2F;&#x2F; 若已经同一层，直接返回
    &#x2F;* 同时往上爬，由大步向小步循环判断，若爬一次两结点相同，暂时认为爬多了 *&#x2F;
	for(int k &#x3D; lg[dep[x]]; k &gt;&#x3D; 0; --k)&#123;
		if(f[x][k] !&#x3D; f[y][k])&#123;
			x &#x3D; f[x][k];
			y &#x3D; f[y][k];
		&#125;
	&#125;
	return f[x][0];
&#125;
&#x2F;* 使用样例 *&#x2F;
int main()&#123;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;root; &#x2F;&#x2F; root是根，LCA是以根节点开始进行dfs的树
	for(int i &#x3D; 0; i &lt; n-1; ++i)&#123; &#x2F;&#x2F; 数据保证为树的话，边数肯定是n-1
        int s,t;
        cin&gt;&gt;s&gt;&gt;t;
        g[s].push_back(t); &#x2F;&#x2F; 注意这是个无向图，dfs确定方向即可
        g[t].push_back(s);
    &#125;
    init(); &#x2F;&#x2F; 预处理
    while(m--)&#123; &#x2F;&#x2F; m次询问
    	int x,y;
    	cin&gt;&gt;x&gt;&gt;y;
    	cout&lt;&lt;LCA(x,y)&lt;&lt;endl;
	&#125;
	return 0;
&#125;</code></pre>



<h2 id="三、高级数据结构"><a href="#三、高级数据结构" class="headerlink" title="三、高级数据结构"></a>三、高级数据结构</h2><h3 id="1、并查集"><a href="#1、并查集" class="headerlink" title="1、并查集"></a>1、并查集</h3><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;带路径压缩：
#define M 100
int f[M]; &#x2F;&#x2F; f[i]表示i的根编号
int find(int x)&#123; &#x2F;&#x2F; 查找根编号
    return f[x] &#x3D;&#x3D; x ? x : f[x] &#x3D; find(f[x]);
&#125;
&#x2F;&#x2F;合并两分量i、j：
f[find(i)] &#x3D; find(j);</code></pre>


<h3 id="2、线段树（segment-Tree）"><a href="#2、线段树（segment-Tree）" class="headerlink" title="2、线段树（segment Tree）"></a>2、线段树（segment Tree）</h3><ul>
<li><blockquote>
<p><font size=4 color=black>经典的例子：从数组a[0…n-1]中查找数组某个区间内的最小值，其中数组大小固定，但是数组中的元素的值可以随时更新。</font></p>
<ul>
<li><font size=4 color=black>解法一：暴力，遍历区间找到最小值。查询时间复杂度O(n)，空间复杂度O(1)</font></li>
<li><font size=4 color=black>解法二：二维数组维护所有子区间。预处理复杂度O(n^2^)，查询时间复杂度O(1)，空间复杂度O(n^2^)</font></li>
<li><font size=4 color=black>解法三：线段树。预处理耗时O(n)，查询、更新操作O(logn)，需要额外空间O(n)</font></li>
</ul>
</blockquote>
</li>
<li><font size=4 color=blue>第一阶段：以维护区间和为例，建立线段树</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">void pushup(int o)&#123;sumv[o]&#x3D;sumv[o&lt;&lt;1]+sumv[o&lt;&lt;1|1];&#125; &#x2F;&#x2F; 向上更新
&#x2F;* 建立线段树 *&#x2F;
void build(int o,int l,int r)&#123; &#x2F;&#x2F; o为当前位置，l为区间左端，r为区间右端
	if(l&#x3D;&#x3D;r)&#123;sumv[o]&#x3D;a[l];return;&#125; &#x2F;&#x2F; 当递归到最后一个位置时，保存区间和sumv
	int mid&#x3D;(l+r)&gt;&gt;1; &#x2F;&#x2F; 取l、r中间值
	build(o&lt;&lt;1,l,mid); &#x2F;&#x2F; 先计算好左子树答案
	build(o&lt;&lt;1|1,mid+1,r); &#x2F;&#x2F; 再计算右子树答案
	pushup(o); &#x2F;&#x2F; 向上更新答案
    &#x2F;&#x2F;sumv[o]&#x3D;sumv[o&lt;&lt;1]+sumv[o&lt;&lt;1|1];
&#125;
&#x2F;* 修改单点的值 *&#x2F;
void change(int o,int l,int r,int q,int v)&#123; &#x2F;&#x2F; 将sumv[q]的数值加上v
	if(l&#x3D;&#x3D;r)&#123;sumv[o]+&#x3D;v;return;&#125; &#x2F;&#x2F; 递归到最后一个位置时，修改答案
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(q&lt;&#x3D;mid) change(o&lt;&lt;1,l,mid,q,v);
	else change(o&lt;&lt;1|1,mid+1,r,q,v);
	pushup(o); 
&#125;
&#x2F;* 查询某区间答案 *&#x2F;
int querysum(int o,int l,int r,int ql,int qr)&#123; &#x2F;&#x2F; 查询[ql,qr]的答案
	if(ql&lt;&#x3D;l &amp;&amp; r&lt;&#x3D;qr)return sumv[o]; &#x2F;&#x2F; 当递归访问到当前区间被包含于ql、qr之间时，直接返回区间答案
	int ans&#x3D;0;
	int mid&#x3D;(l+r)&gt;&gt;1; &#x2F;&#x2F; 注意这里不是（l+r+1）&gt;&gt;1，关系到下面两条语句的判断表达式
	if(ql&lt;&#x3D;mid) ans+&#x3D;querysum(o&lt;&lt;1,l,mid,ql,qr); &#x2F;&#x2F; ql位于左子树（包含当前这个根）
	if(qr&gt;mid) ans+&#x3D;querysum(o&lt;&lt;1|1,mid+1,r,ql,qr); &#x2F;&#x2F; qr位于右子树
	return ans;
&#125;
&#x2F;* 使用样例 *&#x2F;
int n,a[N]; &#x2F;&#x2F; 区间内有n个点需要维护，N为大于n的常数
int sumv[N&lt;&lt;2]; &#x2F;&#x2F; 线段树的数组存储方式，最底层有n个结点所构成的完全二叉树一共有2n-1个结点，一般取4n保险
int main()&#123;
    cin&gt;&gt;n&gt;&gt;m; &#x2F;&#x2F; n个数，m次操作
    for(int i&#x3D;1;i&lt;&#x3D;n;++i) cin&gt;&gt;a[i];
    build(1,1,n); &#x2F;&#x2F; 建树
    while(m--)&#123;
		int opt;cin&gt;&gt;opt; &#x2F;&#x2F; opt&#x3D;&#x3D;1，让x的位置数值增加y；opt&#x3D;&#x3D;2，查询区间[l,r]答案
		if(opt&#x3D;&#x3D;1)&#123;int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);change(1,1,n,x,y);&#125;
		if(opt&#x3D;&#x3D;2)&#123;int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r);printf(&quot;%d\n&quot;,querysum(1,1,n,l,r));&#125;
	&#125;
&#125;</code></pre>

<ul>
<li><font size=4 color=blue>再以维护区间最大值为例，建立线段树</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">void pushup(int o)&#123;maxv[o]&#x3D;max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);&#125; &#x2F;&#x2F; 向上更新
&#x2F;* 建立线段树 *&#x2F;
void build(int o,int l,int r)&#123;
	if(l&#x3D;&#x3D;r)&#123;maxv[o]&#x3D;a[l];return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	build(o&lt;&lt;1,l,mid);
	build(o&lt;&lt;1|1,mid+1,r);
	pushup(o);
    &#x2F;&#x2F;maxv[o]&#x3D;max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);
&#125;
&#x2F;* 修改单点的值 *&#x2F;
void change(int o,int l,int r,int q,int v)&#123; &#x2F;&#x2F; 将sumv[q]的数值加上v
	if(l&#x3D;&#x3D;r)&#123;maxv[o]+&#x3D;v;return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(q&lt;&#x3D;mid)change(o&lt;&lt;1,l,mid,q,v);
	else change(o&lt;&lt;1|1,mid+1,r,q,v);
	pushup(o); 
&#125;
&#x2F;* 查询某区间答案 *&#x2F;
int querymax(int o,int l,int r,int ql,int qr)&#123; &#x2F;&#x2F; 查询[ql,qr]的答案
	if(ql&lt;&#x3D;l &amp;&amp; r&lt;&#x3D;qr)return maxv[o];
	int ans&#x3D;1e9+7;
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(ql&lt;&#x3D;mid) ans &#x3D; max(ans,querymax(o&lt;&lt;1,l,mid,ql,qr));
	if(qr&gt;mid) ans &#x3D; max(ans,querymax(o&lt;&lt;1|1,mid+1,r,ql,qr));
	return ans;
&#125;</code></pre>

<ul>
<li><font size=4 color=red>第二阶段：带标记优化，只有需要访问时才需要返回正确结果，不许要访问的区间若要进行修改，暂时打上标记就行，等需要查询的时候再修改为正确答案</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
const int N&#x3D;1e6+10;
int n,a[N],m;
int sumv[N&lt;&lt;2],addv[N&lt;&lt;2];
&#x2F;&#x2F;以维护区间和为例
void pushup(int o)&#123;sumv[o]&#x3D;sumv[o&lt;&lt;1]+sumv[o&lt;&lt;1|1];&#125;
void build(int o,int l,int r)&#123;
	&#x2F;&#x2F;build函数没改动
	if(l&#x3D;&#x3D;r)&#123;sumv[o]&#x3D;a[l];return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	build(o&lt;&lt;1,l,mid);
	build(o&lt;&lt;1|1,mid+1,r);
	pushup(o);
&#125;
&#x2F;* 设置标记 *&#x2F;
inline void puttag(int o,int l,int r,int v)&#123;
    &#x2F;* 注意标记与线段树要同时修改 *&#x2F;
	addv[o]+&#x3D;v; &#x2F;&#x2F; 标记增加v
    sumv[o]+&#x3D;(r-l+1)*v; &#x2F;&#x2F; 总和增加了（区间长度*v）
&#125;
&#x2F;* 下放标记：将当前位置的标记下放到左右两子区间上 *&#x2F;
void pushdown(int o,int l,int r)&#123;
	if(addv[o]&#x3D;&#x3D;0)return; &#x2F;&#x2F; 若无标记，直接返回
	addv[o&lt;&lt;1]+&#x3D;addv[o]; &#x2F;&#x2F; 将当前标记放到左右两子树上
	addv[o&lt;&lt;1|1]+&#x3D;addv[o];
	int mid&#x3D;(l+r)&gt;&gt;1;
	sumv[o&lt;&lt;1]+&#x3D;addv[o]*(mid-l+1); &#x2F;&#x2F; 修改左子树总和：增加了(标记*左子区间长度）
	sumv[o&lt;&lt;1|1]+&#x3D;addv[o]*(r-mid); &#x2F;&#x2F; 修改右子树总和：增加了(标记*右子区间长度）
	addv[o]&#x3D;0; &#x2F;&#x2F; 当前标记清零
&#125;
&#x2F;* 区间[ql,qr]每个点都增加v *&#x2F;
void optadd(int o,int l,int r,int ql,int qr,int v)&#123;
	if(ql&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;qr)&#123;puttag(o,l,r,v);return;&#125; &#x2F;&#x2F; 当前区间被需要修改的区间包含，直接打上标记
	int mid&#x3D;(l+r)&gt;&gt;1;
	pushdown(o,l,r); &#x2F;&#x2F; 在往后打上新的标记前，需要将祖先的标记下放
	if(ql&lt;&#x3D;mid)optadd(o&lt;&lt;1,l,mid,ql,qr,v);
	if(qr&gt;mid)optadd(o&lt;&lt;1|1,mid+1,r,ql,qr,v);
	pushup(o); &#x2F;&#x2F; 注意修改的时候函数体一定要有pushup;
&#125;
&#x2F;* 查询某区间答案 *&#x2F;
int querysum(int o,int l,int r,int ql,int qr)&#123;
	if(ql&lt;&#x3D;l &amp;&amp; r&lt;&#x3D;qr) return sumv[o]; &#x2F;&#x2F; 直接返回被包含区间的答案
	int ans&#x3D;0;int mid&#x3D;(l+r)&gt;&gt;1;
	pushdown(o,l,r); &#x2F;&#x2F; 需要算子区间答案时，要将祖先区间的所有标记下放到子区间上
	if(ql&lt;&#x3D;mid) ans +&#x3D; querysum(o&lt;&lt;1,l,mid,ql,qr);
	if(qr&gt;mid) ans +&#x3D; querysum(o&lt;&lt;1|1,mid+1,r,ql,qr);
	return ans;
&#125;
&#x2F;* 使用样例 *&#x2F;
int main()&#123;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;a[i];
	build(1,1,n);
	while(m--)&#123;
		int opt;cin&gt;&gt;opt;
		if(opt&#x3D;&#x3D;1)&#123;
            int l,r,v;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;
            optadd(1,1,n,l,r,v);
        &#125;
		if(opt&#x3D;&#x3D;2)&#123;
            int l,r;
            cin&gt;&gt;l&gt;&gt;r;
            cout&lt;&lt;querysum(1,1,n,l,r);
        &#125;
	&#125;
&#125;</code></pre>

<ul>
<li><p><font size=4 color=red>第三阶段：同时维护多种标记</font></p>
</li>
<li><p><font size=4>以加法和乘法为例：</font></p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
const int N&#x3D;1e6+10;
int n,a[N],m;
int sumv[N&lt;&lt;2],addv[N&lt;&lt;2],prov[N&lt;&lt;2]; &#x2F;&#x2F; addv是加法标记、prov是乘法标记
void pushup(int o)&#123;sumv[o]&#x3D;(sumv[o&lt;&lt;1]+sumv[o&lt;&lt;1|1]);&#125;
void build(int o,int l,int r)&#123;
	prov[o]&#x3D;1; &#x2F;&#x2F; 加法标记addv初始化为0，乘法标记prov初始化为1
	if(l&#x3D;&#x3D;r)&#123;sumv[o]&#x3D;a[l];return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	build(o&lt;&lt;1,l,mid);
	build(o&lt;&lt;1|1,mid+1,r);
	pushup(o);
&#125;
void pushdown(int o,int l,int r)&#123; &#x2F;&#x2F; 需要考虑多种标记的冲突问题
	if(addv[o]&#x3D;&#x3D;0&amp;&amp;prov[o]&#x3D;&#x3D;1)return; &#x2F;&#x2F; 当前无特殊标记
    &#x2F;* 若有标记 *&#x2F;
	int mid&#x3D;(l+r)&gt;&gt;1;
    &#x2F;* 修改左右子区间的总和为：原总和×当前乘法标记+子区间长度×当前加法标记 *&#x2F;
	sumv[o&lt;&lt;1]  &#x3D; sumv[o&lt;&lt;1]*prov[o]+addv[o]*(mid-l+1);
	sumv[o&lt;&lt;1|1]&#x3D; sumv[o&lt;&lt;1|1]*prov[o]+addv[o]*(r-mid);
    &#x2F;* 当前的乘法标记下放到左、右子区间 *&#x2F;
	prov[o&lt;&lt;1]  *&#x3D; prov[o];
	prov[o&lt;&lt;1|1]*&#x3D; prov[o];
    &#x2F;* 修改左、右子区间的加法标记为：子区间加法标记×当前乘法标记+当前加法标记 *&#x2F;
	addv[o&lt;&lt;1]  &#x3D; addv[o&lt;&lt;1]*prov[o]+addv[o];
	addv[o&lt;&lt;1|1]&#x3D; addv[o&lt;&lt;1|1]*prov[o]+addv[o];
    &#x2F;* 清零标记 *&#x2F;
	addv[o]&#x3D;0;
	prov[o]&#x3D;1;
&#125;
&#x2F;* [ql,qr]区间每个数都乘上k *&#x2F;
void optpro(int o,int l,int r,int ql,int qr,int k)&#123;
	if(ql&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;qr)&#123; &#x2F;&#x2F; 当前区间被需要修改的区间包含，直接打上标记
		if(addv[o])pushdown(o,l,r); &#x2F;&#x2F; 特判：若当前有加法标记，则需下放
		sumv[o]*&#x3D;k;
		prov[o]*&#x3D;k;	
		return;
	&#125;
	pushdown(o,l,r); &#x2F;&#x2F; 考虑这句话的意义？
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(ql&lt;&#x3D;mid) optpro(o&lt;&lt;1,l,mid,ql,qr,k);
	if(qr&gt;mid) optpro(o&lt;&lt;1|1,mid+1,r,ql,qr,k);
	pushup(o);
&#125;
&#x2F;* [ql,qr]区间每个数都加上v *&#x2F;
void optadd(int o,int l,int r,int ql,int qr,int v)&#123;
	if(ql&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;qr)&#123; &#x2F;&#x2F; 当前区间被需要修改的区间包含，直接打上标记
		sumv[o]+&#x3D;v*(r-l+1);
		addv[o]+&#x3D;v;
		return;
	&#125;
    pushdown(o,l,r);
	int mid&#x3D;(l+r)&gt;&gt;1;
	if(ql&lt;&#x3D;mid)optadd(o&lt;&lt;1,l,mid,ql,qr,v);
	if(qr&gt;mid)optadd(o&lt;&lt;1|1,mid+1,r,ql,qr,v);
	pushup(o);
&#125;
&#x2F;* 查询[ql,qr]区间答案 *&#x2F;
int querysum(int o,int l,int r,int ql,int qr)&#123;
	if(ql&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;qr) return sumv[o];
	int ans&#x3D;0;
	int mid&#x3D;(l+r)&gt;&gt;1;
	pushdown(o,l,r);
	if(ql&lt;&#x3D;mid) ans +&#x3D; querysum(o&lt;&lt;1,l,mid,ql,qr);
	if(qr&gt;mid) ans +&#x3D; querysum(o&lt;&lt;1|1,mid+1,r,ql,qr);
	return ans;
&#125;
&#x2F;* 使用样例：选择1、2、3分别是乘法、加法、查询 *&#x2F;
int main()&#123;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;a[i];
	build(1,1,n);
	while(m--)&#123;
		int opt;cin&gt;&gt;opt;
		if(opt&#x3D;&#x3D;1)&#123;
            int l,r,v;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;
            optpro(1,1,n,l,r,v);
        &#125;
        if(opt&#x3D;&#x3D;2)&#123;
            int l,r,v;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;
            optadd(1,1,n,l,r,v);
        &#125;
		if(opt&#x3D;&#x3D;3)&#123;
            int l,r;
            cin&gt;&gt;l&gt;&gt;r;
            cout&lt;&lt;querysum(1,1,n,l,r)&lt;&lt;endl;
        &#125;
	&#125;
	return 0;
&#125;</code></pre>



<h3 id="3、主席树（可持久化线段树）"><a href="#3、主席树（可持久化线段树）" class="headerlink" title="3、主席树（可持久化线段树）"></a>3、主席树（可持久化线段树）</h3><ul>
<li><font size=4 color=blue>可持久化的含义是：可以任意回退到某种历史状态</font></li>
<li><font size=4 color=blue>例题：给定一个数列a[n](n&lt;=2e5、a[i]&lt;=2e5)，m次查询[l,r]区间第k小的数</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define M 20005
using namespace std;
struct tree &#123;
	int cnt; &#x2F;&#x2F; 每个结点保存了左右子树上某些数出现的次数，最底层的结点保存的数就是某一个数出现的次数
	tree *lson,*rson;
&#125;mem[M&lt;&lt;5],*top[M]; &#x2F;&#x2F; mem提前开好空间，top是连续时间戳上的线段树的根节点
int spaceNum; &#x2F;&#x2F; spaceNum记录分配内存的数量
void build(tree* t,int l,int r)&#123;
    &#x2F;* build是建立初始的线段树，每个数出现的个数均初始化为0 *&#x2F;
	if(l&#x3D;&#x3D;r)&#123;t-&gt;cnt&#x3D;0;return;&#125; 
	int mid&#x3D;(l+r)&gt;&gt;1;
    &#x2F;* 左右儿子内存分配 *&#x2F;
	t-&gt;lson&#x3D;&amp;mem[++spaceNum];
	t-&gt;rson&#x3D;&amp;mem[++spaceNum];
	build(t-&gt;lson,l,mid);
	build(t-&gt;rson,mid+1,r);
	t-&gt;cnt&#x3D;0; 
&#125;
void insert(tree* last,tree* now,int l,int r,int x)&#123;
    &#x2F;* 从头开始遍历a数组，每次向线段树里插入a[i]，表示区间[1,i]上每个数字出现的次数 *&#x2F;
    &#x2F;* 由此，时间戳上每颗线段树（除了第一个初始化的）都是通过前一棵树演变过来的 *&#x2F;
    &#x2F;* 相邻两颗树仅有logn个结点不同，即仅更改了一条路径的结点 *&#x2F;
    &#x2F;* 对于其他没变化的结点，新树共用旧树的结点，不会浪费空间（这就是用指针的妙处）*&#x2F;
	if(l&#x3D;&#x3D;r)&#123;now-&gt;cnt&#x3D;last-&gt;cnt+1;return;&#125;
	int mid&#x3D;(l+r)&gt;&gt;1;
	*now&#x3D;*last; &#x2F;&#x2F; 新树的根初始化与旧树的根相同
    &#x2F;* 判断新加入的x在左子树还是右子树 *&#x2F;
	if(x&lt;&#x3D;mid)&#123;
		now-&gt;lson&#x3D;&amp;mem[++spaceNum];
		insert(last-&gt;lson,now-&gt;lson,l,mid,x);
	&#125;
	else&#123;
		now-&gt;rson&#x3D;&amp;mem[++spaceNum];
		insert(last-&gt;rson,now-&gt;rson,mid+1,r,x);
	&#125;
	now-&gt;cnt &#x3D; now-&gt;lson-&gt;cnt + now-&gt;rson-&gt;cnt; &#x2F;&#x2F; 相当于pushup
&#125;
int query(tree *lastTree,tree *nowTree,int l,int r,int x)&#123;
    &#x2F;* 查询区间[l,r]上第x小的数 *&#x2F;
	if(l&#x3D;&#x3D;r)return l;
	int mid&#x3D;(l+r)&gt;&gt;1;
    &#x2F;* 比较两树的左儿子计数的差与x的大小：如果前者不小于后者，说明所求的第x小的数在左子树上 *&#x2F;
	int temp&#x3D;nowTree-&gt;lson-&gt;cnt - lastTree-&gt;lson-&gt;cnt;
	if(x&lt;&#x3D;temp)return query(lastTree-&gt;lson,nowTree-&gt;lson,l,mid,x);
    &#x2F;* 若后者大于前者，则需要在右子树上求第(x-temp)小的数 *&#x2F;
	else return query(lastTree-&gt;rson,nowTree-&gt;rson,mid+1,r,x-temp);
&#125;
&#x2F;* 使用样例 *&#x2F;
int main()&#123;
    int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;0;i&lt;&#x3D;n;++i)top[i]&#x3D;&amp;mem[++spaceNum]; 
	build(top[0],1,n);
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)insert(top[i-1],top[i],1,n,a[i]);
	while(m--)&#123;
		int l,r,x;
		cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;
		cout&lt;&lt;query(top[l-1],top[r],1,n,x)&lt;&lt;endl;
	&#125;
	return 0;
&#125;</code></pre>



<h3 id="4、树状数组（Binary-Indexed-Tree）"><a href="#4、树状数组（Binary-Indexed-Tree）" class="headerlink" title="4、树状数组（Binary Indexed Tree）"></a>4、树状数组（Binary Indexed Tree）</h3><ul>
<li><p><font size=4 color=blue>求区间<code>[ql,qr]</code>的和，其实只要能求对任意i的区间<code>[1,i]</code>即可，因为<code>[ql,qr]=[1,qr]-[1,ql-1]</code>，也就是说，线段树中右儿子是不必要的，因为有了左儿子和父亲，就能求右儿子的值。</font></p>
</li>
<li><p><font size=4 color=blue>基于这种思路的数据结构就是树状数组。它有着与线段树同样的时间复杂度，但是树状数组的常数更小，代码更短，应用范围也比线段树更加广泛</font></p>
</li>
<li><p>```c++<br>/* 观察树状数组的构造规律 */<br>c[1]=a[1];<br>c[2]=a[1]+a[2];<br>c[3]=a[3];<br>c[4]=a[1]+a[2]+a[3]+a[4];<br>c[5]=a[5];<br>c[6]=a[5]+a[6];<br>c[7]=a[7];<br>c[8]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8];<br>// 1–&gt;0001<br>// 2–&gt;0010<br>// 3–&gt;0011<br>// 4–&gt;0100<br>// 5–&gt;0101<br>// 6–&gt;0110<br>// 7–&gt;0111<br>// 8–&gt;1000</p>
<pre class="language-none"><code class="language-none">
- &lt;font size&#x3D;4&gt;规律：$i$的二进制中从右往左数有$x$个连续的0，那么拥有$2^x$个叶子，为序列A中第$i-2^x+1$到第$i$个元素（共$2^x$个元素）的和。具体求和过程如下：&lt;&#x2F;font&gt;

  - &#96;&#96;&#96;c++
    &#x2F;* 以求s[7]为例 *&#x2F;
    &#x2F;&#x2F; 7--&gt;0111
    c[7]&#x3D;a[7];
    &#x2F;&#x2F; 减去其二进制最后一个1，得0110
    c[6]&#x3D;a[6]+a[5];
    &#x2F;&#x2F; 减去其二进制最后一个1，得0100
    c[4]&#x3D;a[4]+a[3]+a[2]+a[1];
    &#x2F;&#x2F; 减去其二进制最后一个1，得0000，结果为0，结束</code></pre></li>
<li><p><font size=4 color=blue>上述求二进制位最低1的操作被称为lowbit，lowbit函数的实现方法有很多：</font></p>
<ul>
<li>最常见是这种：<code>x &amp; -x</code></li>
<li>若不支持访问负数，可以写成：<code>x &amp; ( x^(x-1) )</code></li>
<li>每次做的这个操作：<code>x -= x &amp; -x</code>，可以写作<code>x = x &amp; (x-1)</code></li>
</ul>
</li>
<li><p><font size=4 color=red>例：O(logn)维护单点修改、区间查询</font></p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define M 10010
#define lowbit(x) x &amp; -x
using namespace std;
int c[M],n; &#x2F;&#x2F; c数组保存了一定的a[]序列中的数
int sum(int x)&#123; &#x2F;&#x2F; 求区间[1,x]的和
    int ans &#x3D; 0;
    while(x &gt; 0)&#123;
        ans +&#x3D; c[x];
        x -&#x3D; lowbit(x);
    &#125;
    return ans;
&#125;
&#x2F;* 单点修改的时候复杂度也为O(logn)，只需要修改某些相关联的c[i]即可 *&#x2F;
void add(int x,int value)&#123;
    &#x2F;* 正好求c[i]的祖先只需要让i加上自己的lowbit *&#x2F;
    while(x &lt;&#x3D; n)&#123;
        c[x] +&#x3D; value;
        x +&#x3D; lowbit(x);
    &#125;
&#125;
&#x2F;* 使用样例：输入区间长度、操作数、每个点的值，每次操作：1 x y表示点x加y，2 x y表示查询区间[x,y] *&#x2F;
int main()&#123;
	int opt,x,y;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;
		cin&gt;&gt;x;
		add(i,x);
	&#125;
	while(m--)&#123;
		cin&gt;&gt;opt&gt;&gt;x&gt;&gt;y;
		if(opt&#x3D;&#x3D;1)add(x,y);
		else if(opt&#x3D;&#x3D;2)cout&lt;&lt;sum(y)-sum(x-1)&lt;&lt;endl;
	&#125;
	return 0;
&#125;</code></pre>

<ul>
<li><font size=4 color=red>变形（树状数组+差分思想）：O(logn)维护区间修改、单点查询</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define M 500010
using namespace std;
int c[M],n,m;
&#x2F;* sum函数与add函数不变 *&#x2F;
&#x2F;* c数组维护的是差分，从而sum(i)求得a[i]的值 *&#x2F;
&#x2F;* 使用样例 *&#x2F;
int main()&#123;
	int opt,x,y,k,c0 &#x3D; 0,c1;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;
        &#x2F;* 每次读入初始单点后，记录差分，并修改c数组 *&#x2F;
		cin&gt;&gt;c1;
		add(i,c1-c0);
		c0&#x3D;c1;
	&#125;
	while(m--)&#123;
		cin&gt;&gt;opt;
		if(opt&#x3D;&#x3D;1)&#123;
			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;
			add(x,k);
			add(y+1,-k);
		&#125;
		else if(opt&#x3D;&#x3D;2)&#123;
			cin&gt;&gt;k;
			cout&lt;&lt;sum(k)&lt;&lt;endl;
		&#125;
	&#125;
	return 0;
&#125;</code></pre>




<h3 id="5、ST表"><a href="#5、ST表" class="headerlink" title="5、ST表"></a>5、ST表</h3><ul>
<li><font size=4 color=blue>给定一个长度为n的序列不修改，m次查询区间的最大值</font></li>
<li><font size=4>对区间内每个点都维护一个从自身到往后2^0^、2^1^、2^2^……个元素组成子区间的答案（总额外空间为nlogn），用二维数组保存这些答案，逻辑上2^0^为第一层、2^1^为第二层……；</font></li>
<li><font size=4>查询时只需要访问（不大于查询区间长度的2的幂次层）答案即可。即若查询区间长度为10，则访问两个2^3^=8的层。</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">void bulid()&#123;
	for(int j &#x3D; 1;j &lt;&#x3D; 16; j++) &#x2F;&#x2F; j是层数
		for(int i &#x3D; 1;i &lt;&#x3D; n; i++)
			f[j][i] &#x3D; max(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]); 
    		&#x2F;&#x2F; 上一层中的两个子区间答案的合并
    		&#x2F;&#x2F; 即1、2与3、4的最大值是1、2、3、4的最大值
&#125;
&#x2F;* 使用样例 *&#x2F;
#define M 100010
int f[17][M],b[M],n,m;
int main()&#123;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;f[0][i];
	bulid();
    &#x2F;* b[len]：给定区间长度len，返回对应层数 *&#x2F;
	for(int i&#x3D;1;i&lt;&#x3D;16;i++)b[1&lt;&lt;i]++;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)b[i]+&#x3D;b[i-1];
	for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;
        int l,r,len;
        cin&gt;&gt;l&gt;&gt;r;
        len&#x3D;r-l+1;
		cout&lt;&lt;max( f[ b[len] ][l],f[ b[len] ][ r+1- (1&lt;&lt;b[len] ) ])
	&#125;
	return 0;
&#125;</code></pre>

<table>
<thead>
<tr>
<th align="center">数组</th>
<th align="center">5</th>
<th align="center">7</th>
<th align="center">12</th>
<th align="center">9</th>
<th align="center">6</th>
<th align="center">4</th>
<th align="center">8</th>
<th align="center">11</th>
<th align="center">3</th>
<th align="center">9</th>
<th align="center">1</th>
<th align="center">6</th>
<th align="center">2</th>
<th align="center">10</th>
<th align="center">7</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2^1^=2</td>
<td align="center">7</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">9</td>
<td align="center">6</td>
<td align="center">8</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">6</td>
<td align="center">6</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2^2^=4</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">9</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2^3^=8</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">11</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">7</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">×</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">×</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><font size=4>查询从第4个（9）数到第14个数（10）中的最大值：区间长度为11，查2^3^那层（两×位置）最大值为11。</font></li>
</ul>
<h3 id="6、二叉树求先序遍历"><a href="#6、二叉树求先序遍历" class="headerlink" title="6、二叉树求先序遍历"></a>6、二叉树求先序遍历</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
void ans(string z,string h)
&#123;
	if(z.size())
	&#123;
		char c&#x3D;h[h.size()-1];
		cout&lt;&lt;c;
		int t&#x3D;z.find(c);
		ans(z.substr(0,t),h.substr(0,t));
		ans(z.substr(t+1),h.substr(t,z.size()-t-1));
	&#125;
&#125;
int main()
&#123;
	string z,h;
	cin&gt;&gt;z&gt;&gt;h;
	ans(z,h);
	return 0; 
&#125; </code></pre>

<h3 id="7、先序中序还原二叉树（整数）"><a href="#7、先序中序还原二叉树（整数）" class="headerlink" title="7、先序中序还原二叉树（整数）"></a>7、先序中序还原二叉树（整数）</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
vector&lt;int&gt; inorder, preorder;
class treeNode&#123;
public:
    int val;
    treeNode* left;
    treeNode* right;
    treeNode(int v): val(v)&#123;
        left &#x3D; right &#x3D; NULL;
    &#125;
&#125;;
treeNode* make(int ii, int ij, int pi, int pj)&#123; &#x2F;&#x2F; 关键递归函数，注意细节
    if(ii &gt; ij) return NULL;
    treeNode* root &#x3D; new treeNode(preorder[pi]); &#x2F;&#x2F; 取先序遍历的第一个作为根
    int ind &#x3D; find(inorder.begin() + ii, inorder.begin() + ij + 1, root-&gt;val) - inorder.begin(); &#x2F;&#x2F; 在中序遍历中寻找这个根
    root-&gt;left &#x3D; make(ii, ind - 1, pi + 1, ind - ii + pi); &#x2F;&#x2F; 第四个参数是计算而得
    root-&gt;right &#x3D; make(ind + 1, ij, pj - ij + ind + 1, pj); &#x2F;&#x2F; 第三个参数计算而得
    return root;
&#125;
int main()&#123;
    int n; cin&gt;&gt;n;
    inorder.resize(n);
    preorder.resize(n);
    for(int i &#x3D; 0; i &lt; n; ++i)&#123;
        cin&gt;&gt;inorder[i];
    &#125;
    for(int i &#x3D; 0; i &lt; n; ++i)&#123;
        cin&gt;&gt;preorder[i];
    &#125;
    treeNode* root &#x3D; make(0, n - 1, 0, n - 1);
    return 0;
&#125;
</code></pre>





<h3 id="2、字符串匹配算法——KMP"><a href="#2、字符串匹配算法——KMP" class="headerlink" title="2、字符串匹配算法——KMP"></a>2、字符串匹配算法——KMP</h3><ul>
<li><font size=4 color=blue>概念不再赘述，复杂度为O(n+m)</font></li>
<li><font size=4>匹配失败时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符的next值</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;* 求next数组 *&#x2F;
&#x2F;&#x2F; 方法一：next数组初始化为0
for(int i &#x3D; 1, j &#x3D; 0; i &lt; s.size(); ++i)&#123; &#x2F;&#x2F; s是子串，求子串的next数组
    while(j &amp;&amp; s[i] !&#x3D; s[j]) j &#x3D; next[j-1]; &#x2F;&#x2F; j&#x3D;&#x3D;0表示不能再往回跳了
    if(s[j] &#x3D;&#x3D; s[i]) j++;
    kmp[i] &#x3D; j;
&#125;
&#x2F;&#x2F; 方法二：next[0]初始化为-1，其余为0，next[i]的值是i-1位字符的next值
next[0] &#x3D; -1;
int i &#x3D; 0, j &#x3D; -1;
while (i &lt; s.size() - 1) &#123;
    if (j &#x3D;&#x3D; -1 || p[i] &#x3D;&#x3D; p[j])
        next[++i] &#x3D; ++j;
    else
        j &#x3D; next[j];
&#125;
&#x2F;* 匹配过程 *&#x2F;
&#x2F;&#x2F; 由于子串的下标是从0开始，next[j]既可表示当前字符匹配了多长前缀，还能表示需要与子串的哪个位置做新一轮比较
for(int i &#x3D; 0, j &#x3D; 0; i &lt; str.size(); ++i)&#123;
    while(j &amp;&amp; s[j] !&#x3D; str[i]) j &#x3D; next[j-1]; &#x2F;&#x2F; j不为子串的开头、且当前字符不匹配时，向前跳
    if(s[j] &#x3D;&#x3D; str[i]) j++; &#x2F;&#x2F; 当前字符串匹配
    if(j &#x3D;&#x3D; s.size())&#123; &#x2F;&#x2F; 当匹配数与子串长度相等时，匹配成功
        cout&lt;&lt;i-s.size()+2&lt;&lt;endl; &#x2F;&#x2F; 输出位置(下标为1开始)
        j &#x3D; next[j-1]; &#x2F;&#x2F; j向前跳一次
    &#125;
&#125;</code></pre>



<h3 id="3、字符串匹配算法——Sunday"><a href="#3、字符串匹配算法——Sunday" class="headerlink" title="3、字符串匹配算法——Sunday"></a>3、字符串匹配算法——Sunday</h3><ul>
<li><font size=4 color=blue>Sunday算法，理解起来则是非常容易，平均时间复杂度为O(n)，但最坏的情况下是O(n*m)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;* 预处理move数组：move[&#39;i&#39;]&#x3D;模式串长度-&#39;i&#39;字符在模式串中最后出现时的下标，move[其他]&#x3D;模式串长度+1 *&#x2F;
#define M 210
int move[M];
for(int i &#x3D; 0; i &lt; M; ++i) move[i]&#x3D;s.size() + 1;
for(int i &#x3D; 0; i &lt; s.size(); ++i) move[s[i]] &#x3D; s.size() - i;
&#x2F;* 具体匹配过程 *&#x2F;
int i &#x3D; 0,j; &#x2F;&#x2F; i表示主串匹配位置，j是模式串匹配位置
while(i &lt;&#x3D; str.size() - s.size())&#123;
    j &#x3D; 0;
    while(str[i+j] &#x3D;&#x3D; s[j])&#123;
        ++j;
        ++i;
        if(j &#x3D;&#x3D; s.size()) cout&lt;&lt;i&lt;&lt;endl; &#x2F;&#x2F; 匹配成功
        continue;
    &#125;
    i +&#x3D; move[s[i + s.size()]]; &#x2F;&#x2F; 取模式串结束位置的下一个位置在主串中的字符c，i移动move[c]的距离
&#125;</code></pre>

<ul>
<li>看上去简单高效非常美好的Sunday算法，也有一些缺点。例如下面一个例子：<ul>
<li>主串：baaabaaabaaa、模式串：aaaa</li>
<li>这个模式串使得move[a]的值为1，即每次匹配失败时，只让模式串向后移动一位再进行匹配。这样就让Sunday算法的时间复杂度飙升到了O(m*n)，也就是字符串匹配的最坏情况</li>
</ul>
</li>
</ul>
<h2 id="五、排序"><a href="#五、排序" class="headerlink" title="五、排序"></a>五、排序</h2><h3 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h3><ul>
<li><font size=4 color=red>裸模板：尚未优化（容易被卡死）：</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#define M 100010
int a[M];
void qsort(int low,int high)&#123;
    if(low&gt;&#x3D;high)
        return ;
    int i&#x3D;low,j&#x3D;high,k&#x3D;a[low];
    while(i&lt;j)&#123;
        while(i&lt;j&amp;&amp;a[j]&gt;&#x3D;k)
            j--;
        if(i&lt;j)
            a[i++]&#x3D;a[j];
        while(i&lt;j&amp;&amp;a[i]&lt;&#x3D;k)
            i++;
        if(i&lt;j)
            a[j--]&#x3D;a[i];
    &#125;
    a[i]&#x3D;k;
    qsort(low,i-1);
    qsort(i+1,high);
&#125;</code></pre>



<h3 id="2、堆排序实现优先队列"><a href="#2、堆排序实现优先队列" class="headerlink" title="2、堆排序实现优先队列"></a>2、堆排序实现优先队列</h3><ul>
<li><font size=4 color=blue>用数组来维护完全二叉树，且满足任意父结点小于（或大于）其子结点，称其为小根堆（或大根堆）。插入、删除的复杂度O(logn)，查询最值复杂度O(1)</font></li>
<li><font size=4>插入过程：将新结点放入完全二叉树最后，并判断是否上浮</font></li>
<li><font size=4>弹出过程：完全二叉树最后一个结点替换掉根结点，并判断是否下沉</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;* 以下以整数小根堆为例 *&#x2F;
int minHeap[10010],mHnum&#x3D;0; &#x2F;&#x2F; 数组维护完全二叉树，mHnum是结点个数
void push(int ev)&#123;
	int num&#x3D;++mHnum; &#x2F;&#x2F; num是新结点的索引值
	bool flag&#x3D;true; &#x2F;&#x2F; 判断是否还需要上浮
	minHeap[num]&#x3D;ev; &#x2F;&#x2F; 将新值加入完全二叉树的最后
	while(num&#x2F;2 &amp;&amp; flag)&#123; &#x2F;&#x2F; 与父结点进行比较，直到自己是根结点或不需上浮
		flag&#x3D;false;
		if(minHeap[num] &lt; minHeap[num&#x2F;2])&#123;
			int temp&#x3D;minHeap[num];
			minHeap[num]&#x3D;minHeap[num&#x2F;2];
			minHeap[num&#x2F;2]&#x3D;temp;
			flag&#x3D;true;
			num&#x2F;&#x3D;2;
		&#125;
	&#125;
&#125;
void pop()&#123;
	if(mHnum&#x3D;&#x3D;0) return ; &#x2F;&#x2F; 小根堆为空 
	minHeap[1]&#x3D;minHeap[mHnum]; &#x2F;&#x2F; 根被替换
	minHeap[mHnum--] &#x3D; 0; &#x2F;&#x2F; 清除末尾结点
	int num&#x3D;1,better; &#x2F;&#x2F; num是新结点的索引值
	bool flag&#x3D;true; &#x2F;&#x2F; 判断是否还需要下沉
	while(num*2&lt;&#x3D;mHnum &amp;&amp; flag)&#123; &#x2F;&#x2F; 与子结点进行比较，直到自己没有子结点或不需下沉
		flag&#x3D;false;
		better&#x3D;num*2; &#x2F;&#x2F; better是子结点的索引值，需要比较左右两个儿子哪个与父亲交换
		if(better+1&lt;&#x3D;mHnum &amp;&amp; minHeap[num*2]&gt;minHeap[num*2+1]) better++; &#x2F;&#x2F; 右儿子更优
		if(minHeap[num]&gt;minHeap[better])&#123;
			int temp&#x3D;minHeap[num];
			minHeap[num]&#x3D;minHeap[better];
			minHeap[better]&#x3D;temp;
			flag&#x3D;true;
			num&#x3D;better;
		&#125;
	&#125;
&#125;</code></pre>









<h2 id="七、筛法"><a href="#七、筛法" class="headerlink" title="七、筛法"></a>七、筛法</h2><h3 id="1、埃氏（Eratosthenes）筛法"><a href="#1、埃氏（Eratosthenes）筛法" class="headerlink" title="1、埃氏（Eratosthenes）筛法"></a>1、埃氏（Eratosthenes）筛法</h3><ul>
<li><font size=4 color=blue>从2到n枚举整数i，若i没被标记，则i为质素；若i为质素，标记大于i且不大于n的i的倍数。复杂度为O(nloglogn)</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">bool flag[N+1];
vector&lt;int&gt; p;
void sieve(int n)&#123;
    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;
        if(!flag[i])&#123;
            p.push_back(i);
            &#x2F;* 注意这个下面这个for语句要放在if内，否则会出现重复标记 *&#x2F;
            &#x2F;* 如4的倍数的标记已经被2标记过了，复杂度会降为O(nlogn) *&#x2F;
        	for(int j &#x3D; i*2; j &lt;&#x3D; N; j +&#x3D; i)
            	flag[j] &#x3D; true;
        &#125;
    &#125;
&#125;</code></pre>



<h3 id="2、线性筛（欧拉筛法）"><a href="#2、线性筛（欧拉筛法）" class="headerlink" title="2、线性筛（欧拉筛法）"></a>2、线性筛（欧拉筛法）</h3><ul>
<li><font size=4 color=blue>埃氏筛法中，一个非素数可能会有很多次被判断，比如12，可以有2×6排除，3×4排除。如果可以避免这些重复，那么复杂度就可以再降到O(n)</font></li>
<li><font size=4 color=blue>从2到n枚举整数i，再从小到大枚举所有不大于i的最小质因子的质素p0，标记ip0。显然，枚举到的p0总是ip0的最小质因子，而更大的p0均不可能是ip0的最小质因子。同样，枚举到i时，若i没有被标记过，则i为质数</font></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">bool flag[N+1];
vector&lt;int&gt; p; &#x2F;&#x2F; 依次保存n以内的质素
void sieve(int n)&#123;
    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;
        if(!flag[i]) p.push_back(i); &#x2F;&#x2F; i为质素，直接放入p内
    	for(int j &#x3D; 0; i*p[j] &lt;&#x3D; N; ++j)&#123;
        	flag[i*p[j]] &#x3D; true;
        	if(i%p[j] &#x3D;&#x3D; 0)break; &#x2F;&#x2F; 关键一步
        &#125;
    &#125;
&#125;</code></pre>

<ul>
<li><font size=4>从质因数分解的角度看，任意一个正整数（除了1以外）都可以分解成一个质素乘另一个数，不妨要求这个质素尽可能小。比如原本对于整数12来说，经过了2次标记（2×6、3×4），但是按照要求只有2的6倍能对12进行标记，但是如何舍去3×4呢？</font></li>
<li><font size=4>其实代码的执行过程并不是主动舍弃多余的，而是直接略过可能发生重复的。具体过程像这样：</font><ul>
<li>2筛去了4；</li>
<li>3筛去了6、9；</li>
<li>4筛去了8；（由于4%2==0，不会进行“4×3”的置true步骤）</li>
<li>5筛去了10、15、25；</li>
<li>6筛去了12（由于6%2==0，不会进行“6×3”的步骤，而18最后会被“2×9”筛去</li>
<li>……</li>
</ul>
</li>
<li><font size=4>总而言之，每个将被标记的数只会被其因数中最小质素标记，仅有一次，这样就把复杂度降低了</font></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2020/10/10/%E7%BB%8F%E5%85%B8%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" data-id="ckmm2kglj0024649vhje8537x" data-title="经典基础算法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符串高精度运算" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/" class="article-date">
  <time class="dt-published" datetime="2020-07-03T16:00:00.000Z" itemprop="datePublished">2020-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/">字符串高精度运算</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p> <font color=blue>由于long long类型表示整数范围也有限，在数的位数超过一定限度做运算时，考虑用字符串模拟运算过程，以达到运算要求。这个过程叫高精度运算</font></p>
</blockquote>
<ul>
<li><font size=4 color=red>以下操作仅对于正整数为例</font></li>
</ul>
<h3 id="一、加法"><a href="#一、加法" class="headerlink" title="一、加法"></a>一、加法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 为了方便操作，函数add中的两个形参均反转保存运算的两个数 */</span>
<span class="token comment">/* 调用该函数时，可以考虑调用前反转两个字符串，也可以调用后在add函数中反转 */</span>
<span class="token comment">/* 在两个字符串尾部添加'0'，在i、j分别指向最后的时候不再往后延伸，合并了不同情况*/</span>
<span class="token comment">/* 函数中封装了对不同进制的适应，默认进制是十进制(base=10) */</span>
<span class="token comment">/* 但原本A至F暂时由'9'后面的6个字符代替，记得最后要转换回'A'至'F'*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span>
string <span class="token function">myAdd</span><span class="token punctuation">(</span>string s1<span class="token punctuation">,</span> string s2<span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> c<span class="token operator">:</span> s1<span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span> c <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token string">'A'</span> <span class="token operator">+</span> <span class="token string">'0'</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> c<span class="token operator">:</span> s2<span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span> c <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token string">'A'</span> <span class="token operator">+</span> <span class="token string">'0'</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token function">reverse</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 以上为预处理</span>
	<span class="token keyword">int</span> next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> evSum<span class="token punctuation">;</span>
	string ans<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		evSum <span class="token operator">=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">+</span> s2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">+</span> next<span class="token punctuation">;</span>
		next <span class="token operator">=</span> evSum <span class="token operator">/</span> base<span class="token punctuation">;</span>
		evSum <span class="token operator">%=</span> base<span class="token punctuation">;</span>
		ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">+</span> evSum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">!=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">+</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> c<span class="token operator">:</span> ans<span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span> c <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">-</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h3 id="二、减法"><a href="#二、减法" class="headerlink" title="二、减法"></a>二、减法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 思想同高精度加法，但是处理减成负数的情况比较麻烦，这里暂时是添加符号来解决 */</span>
<span class="token comment">/* 此算法要求两个字符串均表示正数 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span>
string <span class="token function">myMinus</span><span class="token punctuation">(</span>string s1<span class="token punctuation">,</span> string s2<span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    string ans<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 是否添加负号标记</span>
    <span class="token comment">/* 先做调整，保证s1-s2够减 */</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
	<span class="token function">reverse</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s2<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 以上为预处理</span>
	<span class="token keyword">int</span> next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> evSum<span class="token punctuation">;</span> <span class="token comment">// next表示借位，evSum保存当前两个数位处理后的数字</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		evSum <span class="token operator">=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> s2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>evSum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 需要借位</span>
            evSum <span class="token operator">+=</span> base<span class="token punctuation">;</span>
            next <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 标记借位</span>
        <span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 清除借位</span>
		ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">+</span> evSum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">!=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h3 id="三、乘法"><a href="#三、乘法" class="headerlink" title="三、乘法"></a>三、乘法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 整体思路：相对于竖式笔算，每一位上的乘法运算结果先不进行进位，等所有位都算好之后再统一进位*/</span>
<span class="token comment">/* 细节：两个数相乘后，新的数的位数不超过原本两个数的位数之和，不少于和减一 */</span>
<span class="token comment">/* 同样是先反转字符串 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
string <span class="token function">times</span><span class="token punctuation">(</span>string s1<span class="token punctuation">,</span> string s2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 特判，否则下面代码可能会输出好多个'0'</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> <span class="token string">"0"</span> <span class="token operator">||</span> s2 <span class="token operator">==</span> <span class="token string">"0"</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">reverse</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    string ans<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录每个数位乘积的结果，初始化为0</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
    		v<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 处理进位 */</span>
    <span class="token comment">// 注意：v的最后一位产生于前者的进位</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            v<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token comment">// 若两数相乘后未产生进位，则删去最后多的0</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token comment">// 倒序保存，正序返回</span>
    	ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h3 id="四、除法"><a href="#四、除法" class="headerlink" title="四、除法"></a>四、除法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* s1/s2 不考虑余数 */</span>
<span class="token comment">/* 相比于上面其他的运算，除法不需要反转字符串，因为本身就是从高位开始计算 */</span>
<span class="token comment">/* 过程等同于竖式计算，每一位上的答案用对应位相减的方法算 */</span>
string <span class="token function">divide</span><span class="token punctuation">(</span>string s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string s2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 两者大小判断</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s1比s2小，相除后整数部分为0</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s1比s2小，相除后整数部分为0</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    s1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在s1最前面补0，适用于借位</span>
    string ans<span class="token punctuation">;</span>
    <span class="token keyword">int</span> next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录借位，next=1表示借了位</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 减法操作，直至不够减时退出循环，最多执行10次</span>
    		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// s2从后往前按位减于s1</span>
	    		s1<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">-=</span> s2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span> <span class="token operator">+</span> next<span class="token punctuation">;</span>
	    		next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	    		<span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// s1当前小于0，则向前借位</span>
	    			s1<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	    			next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>	
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 最高位也借位</span>
				<span class="token operator">--</span>s1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 最高位无法借位时，s1重新加回s2，并记录答案、退出循环</span>
	    		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		    		s1<span class="token punctuation">[</span>j<span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> s2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span> <span class="token operator">+</span> next<span class="token punctuation">;</span>
		    		next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		    		<span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		    			s1<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		    			next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
					<span class="token punctuation">&#125;</span>	
				<span class="token punctuation">&#125;</span>				
				<span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
					<span class="token operator">++</span>s1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
					next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录这一位答案</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span>
        ans<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把ans前所有打头的‘0’都删掉</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* s1/s2 将s1变为余数 */</span>
<span class="token comment">/* 上述代码稍作修改即可 */</span>
string <span class="token function">divide</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string s2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 1.函数原型传参s1为引用</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把ans前所有打头的‘0’都删掉</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> s1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把s1前所有打头的‘0’都删掉</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> s1 <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span> <span class="token comment">// 余数为0，上条代码删除了所有‘0’，补上一个‘0’</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2020/07/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/" data-id="ckmm2kgld001v649v3p75cuxu" data-title="字符串高精度运算" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AB%98%E7%B2%BE%E5%BA%A6/" rel="tag">字符串高精度</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-STL：bitset用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/05/STL%EF%BC%9Abitset%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-06-04T16:00:00.000Z" itemprop="datePublished">2020-06-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/STL%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/">STL常用模板总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/05/STL%EF%BC%9Abitset%E7%94%A8%E6%B3%95/">STL：bitset用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>​        <font color = blue>有些程序要处理二进制位的有序集，每个位可能包含的是0（关）或1（开）的值。位是用来保存一组项或条件的yes/no信息（有时也称标志）的简洁方法。标准库提供了bitset类使得处理位集合更容易一些。要使用bitset类就必须要包含相关的头文件。</font></p>
</blockquote>
<ul>
<li>使用时包含头文件<code>#include&lt;bitset&gt;</code></li>
</ul>
<h3 id="一、bitset的创建"><a href="#一、bitset的创建" class="headerlink" title="一、bitset的创建"></a>一、bitset的创建</h3><ul>
<li>普通创建</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">bitset<span class="token operator">&lt;</span>n<span class="token operator">></span> b<span class="token punctuation">;</span>	          <span class="token comment">// b有n位，每位都为0</span>
<span class="token comment">// 例如：</span>
bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> bitvec<span class="token punctuation">;</span> <span class="token comment">// 32位，全为0</span></code></pre>

<ul>
<li>用<code>unsigned</code>值初始化<code>bitset</code>对象</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">bitset<span class="token operator">&lt;</span>n<span class="token operator">></span> <span class="token function">b</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>	          <span class="token comment">// b是unsigned long型u的一个副本</span>
<span class="token comment">// bitvec1 is smaller than the initializer</span>
bitset<span class="token operator">&lt;</span><span class="token number">16</span><span class="token operator">></span> <span class="token function">bitvec1</span><span class="token punctuation">(</span><span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bits 0 ... 15 are set to 1</span>
<span class="token comment">// bitvec2 same size as initializer</span>
bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> <span class="token function">bitvec2</span><span class="token punctuation">(</span><span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bits 0 ... 15 are set to 1; 16 ... 31 are 0</span>
<span class="token comment">// on a 32-bit machine, bits 0 to 31 initialized from 0xffff</span>
bitset<span class="token operator">&lt;</span><span class="token number">128</span><span class="token operator">></span> <span class="token function">bitvec3</span><span class="token punctuation">(</span><span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bits 32 through 127 initialized to zero</span></code></pre>

<ul>
<li>用string对象初始化<code>bitset</code>对象</li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">bitset<span class="token operator">&lt;</span>n<span class="token operator">></span> <span class="token function">b</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>	          <span class="token comment">// b是string对象s中含有的位串的副本</span>
string <span class="token function">strval</span><span class="token punctuation">(</span><span class="token string">"1100"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> <span class="token function">bitvec4</span><span class="token punctuation">(</span>strval<span class="token punctuation">)</span><span class="token punctuation">;</span>
bitset<span class="token operator">&lt;</span>n<span class="token operator">></span> <span class="token function">b</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>	  <span class="token comment">// b是s中从位置pos开始的n个位的副本</span>
string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"1111111000000011001101"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> <span class="token function">bitvec5</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4 bits starting at str[5], 1100</span>
bitset<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">></span> <span class="token function">bitvec6</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// use last 4 characters</span></code></pre>

<h3 id="二、部分操作函数"><a href="#二、部分操作函数" class="headerlink" title="二、部分操作函数"></a>二、部分操作函数</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">b<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否存在1</span>
b<span class="token punctuation">.</span><span class="token function">none</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否不存在1</span>
b<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1的个数</span>
b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b中二进制位的个数</span>
b<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 取pos位的值</span>
b<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token comment">// pos位置是否为1</span>
b<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 所有位置为1</span>
b<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pos置为1</span>
b<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 所有位置为0</span>
b<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pos置为0</span>
b<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 所有位取反</span>
b<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pos处取反</span>
b<span class="token punctuation">.</span><span class="token function">to_ulong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个unsigned long</span>
b<span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个string</span></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2020/06/05/STL%EF%BC%9Abitset%E7%94%A8%E6%B3%95/" data-id="ckmm2kgki000m649v50oq7rmh" data-title="STL：bitset用法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-STL：map用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/21/STL%EF%BC%9Amap%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-05-20T16:00:00.000Z" itemprop="datePublished">2020-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/STL%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/">STL常用模板总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/21/STL%EF%BC%9Amap%E7%94%A8%E6%B3%95/">STL：map用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><font color=blue>        Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。</font></p>
<p><font color=blue>        这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</font></p>
</blockquote>
<ul>
<li><p>它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。</p>
</li>
<li><p>对于迭代器来说，可以修改实值，而不能修改key。</p>
</li>
<li><p><strong>map的功能</strong></p>
<ul>
<li><p>自动建立Key － value的对应。key 和 value可以是任意你需要的类型。</p>
</li>
<li><p><strong>根据key值快速查找记录，查找的复杂度基本是Log</strong>(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。</p>
</li>
<li><p>快速插入Key -Value 记录。</p>
</li>
<li><p>快速删除记录</p>
</li>
<li><p>根据Key 修改value记录。</p>
</li>
<li><p>遍历所有记录。</p>
</li>
</ul>
</li>
<li><p><font color=red>使用时包含头文件<code>#include&lt;map&gt;</code></font></p>
</li>
</ul>
<h3 id="一、map的创建"><a href="#一、map的创建" class="headerlink" title="一、map的创建"></a>一、map的创建</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// map&lt;typename1,typename2> mp;</span>
map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>string<span class="token operator">></span> m1<span class="token punctuation">;</span>
map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">></span> m2<span class="token punctuation">;</span>
map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> m3<span class="token punctuation">;</span>
map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> m4<span class="token punctuation">;</span>
map<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span>string<span class="token operator">></span> m5<span class="token punctuation">;</span>
map<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> m6<span class="token punctuation">;</span>
map<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span>string<span class="token operator">></span> m7<span class="token punctuation">;</span></code></pre>

<h3 id="二、插入元素"><a href="#二、插入元素" class="headerlink" title="二、插入元素"></a>二、插入元素</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//以 map&lt;int,string> mp 为例</span>
<span class="token comment">//第一种：用insert函數插入pair</span>
mp<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mp<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token comment">//第二种：用insert函数插入value_type数据</span>
mp<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">map</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span><span class="token function">value_type</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mp<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">map</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span><span class="token function">value_type</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token comment">//第三种：用数组方式插入</span>
mp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"one"</span><span class="token punctuation">;</span>
mp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"two"</span><span class="token punctuation">;</span></code></pre>

<h3 id="三、map的遍历"><a href="#三、map的遍历" class="headerlink" title="三、map的遍历"></a>三、map的遍历</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span> 
<span class="token keyword">for</span><span class="token punctuation">(</span>iter <span class="token operator">=</span> mp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>
    cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-></span>first<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token comment">//以下为反向迭代器</span>
map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>reverse_iterator iter<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>iter <span class="token operator">=</span> mp<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>  
    cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-></span>first<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token comment">//数组方式（要求比较苛刻，如：键类型为int）</span>
<span class="token keyword">int</span> nSize <span class="token operator">=</span> mp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> nindex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> nindex <span class="token operator">&lt;=</span> nSize<span class="token punctuation">;</span> nindex<span class="token operator">++</span><span class="token punctuation">)</span>    
    cout<span class="token operator">&lt;&lt;</span>mapStudent<span class="token punctuation">[</span>nindex<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre>

<h3 id="四、查找操作"><a href="#四、查找操作" class="headerlink" title="四、查找操作"></a>四、查找操作</h3><ul>
<li><p><font size=3>第一种：用count函数来判定关键字是否出现，其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了。</font></p>
</li>
<li><p><font size=3>第二种：用find()函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end()函数返回的迭代器。<strong>传入的参数是要查找的key</strong></font></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>  
iter <span class="token operator">=</span> mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">if</span><span class="token punctuation">(</span>iter <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Find, the value is "</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> 
<span class="token keyword">else</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"Not Find"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre></li>
<li><p>第三种：这个方法用来判定数据是否出现。<del>（显得笨了点）</del></p>
<p><code>lower_bound()</code>函数用法，这个函数用来返回要查找关键字的下界(是一个迭代器)</p>
<p><code>upper_bound()</code>函数用法，这个函数用来返回要查找关键字的上界(是一个迭代器)</p>
<p><code>Equal_range()</code>函数返回一个pair，pair里面第一个变量是<code>Lower_bound</code>返回的迭代器，pair里面第二个迭代器是<code>Upper_bound</code>返回的迭代器，如果这两个迭代器相等的话，则说明map中不出现这个关键字</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">pair<span class="token operator">&lt;</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator<span class="token punctuation">,</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator<span class="token operator">></span> mappair<span class="token punctuation">;</span>  
mappair <span class="token operator">=</span> mp<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">if</span><span class="token punctuation">(</span>mappair<span class="token punctuation">.</span>first <span class="token operator">==</span> mappair<span class="token punctuation">.</span>second<span class="token punctuation">)</span>  
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"Not Find"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
<span class="token keyword">else</span>  
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"Find"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  </code></pre></li>
</ul>
<h3 id="五、删除操作"><a href="#五、删除操作" class="headerlink" title="五、删除操作"></a>五、删除操作</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过一个条目对象删除</span>
iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator first，iterator last<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除一个范围</span>
size_type <span class="token function">erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> Key<span class="token operator">&amp;</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过关键字删除</span>
<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 就相当于enumMap.erase(enumMap.begin(), enumMap.end());</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>  
iter <span class="token operator">=</span> mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
mp<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除成功返回1，否则返回0</span>
mp<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等同于mp.clear();</span></code></pre>

<h3 id="六、基本操作函数"><a href="#六、基本操作函数" class="headerlink" title="六、基本操作函数"></a>六、基本操作函数</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指向map头部的迭代器</span>
<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除所有元素</span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指定元素出现的次数</span>
<span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果map为空则返回true</span>
<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指向map末尾的迭代器</span>
<span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回特殊条目的迭代器对</span>
<span class="token function">erase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除一个元素</span>
<span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查找一个元素</span>
<span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回map的配置器</span>
<span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 插入元素</span>
<span class="token function">key_comp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回比较元素key的函数</span>
<span class="token function">lower_bound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回键值>=给定元素的第一个位置</span>
<span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回可以容纳的最大元素个数</span>
<span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个指向map尾部的逆向迭代器</span>
<span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个指向map头部的逆向迭代器</span>
<span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回map中元素的个数</span>
<span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换两个map</span>
<span class="token function">upper_bound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回键值>给定元素的第一个位置</span>
<span class="token function">value_comp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回比较元素value的函数</span></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2020/05/21/STL%EF%BC%9Amap%E7%94%A8%E6%B3%95/" data-id="ckmm2kgkn000u649v9yj7haxq" data-title="STL：map用法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-STL：set用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/21/STL%EF%BC%9Aset%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-05-20T16:00:00.000Z" itemprop="datePublished">2020-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/STL%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/">STL常用模板总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/21/STL%EF%BC%9Aset%E7%94%A8%E6%B3%95/">STL：set用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><font color=blue>        set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。应该注意的是set中数元素的值不能直接被改变。</font></p>
<p><font color=blue>        C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般平衡二叉树，所以被STL选择作为了关联容器的内部结构。</font></p>
</blockquote>
<ul>
<li><font color=red>注意：set集合中元素排好序、元素无重复</font></li>
<li><font color=red>高效的插入、删除和查询操作，其时间复杂度是O（logn） 。而数组插入时间复杂度是O(1)，但删除和查询都是O(n)，时间效率低</font></li>
<li><font color=red>使用时包含头文件<code>#include&lt;set&gt;</code></font></li>
</ul>
<h3 id="一、set的创建"><a href="#一、set的创建" class="headerlink" title="一、set的创建"></a>一、set的创建</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span> <span class="token comment">// 创建空set</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">iset</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化</span></code></pre>

<h3 id="二、插入元素"><a href="#二、插入元素" class="headerlink" title="二、插入元素"></a>二、插入元素</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//set&lt;int> s;</span>
<span class="token function">insert</span><span class="token punctuation">(</span>key_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一种插入，返回值是pair&lt;set&lt;int>::iterator,bool>，bool标志着插入是否成功，而iterator代表插入的位置，若key_value已经在set中，则iterator表示的key_value在set中的位置，bool返回false</span>
<span class="token function">inset</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二种插入，返回值是void</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一种在集合中插入元素5</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>a<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二种插入a数组</span></code></pre>

<h3 id="三、查找元素"><a href="#三、查找元素" class="headerlink" title="三、查找元素"></a>三、查找元素</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token punctuation">;</span>
ite1 <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查找元素3</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>i1 <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"3 found"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre>

<h3 id="四、删除元素"><a href="#四、删除元素" class="headerlink" title="四、删除元素"></a>四、删除元素</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">erase</span><span class="token punctuation">(</span>iterator<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除定位器iterator指向的值</span>
<span class="token function">erase</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除定位器first和second之间的值</span>
<span class="token function">erase</span><span class="token punctuation">(</span>key_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除键值key_value的值</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一种删除</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator first<span class="token punctuation">;</span>
set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator second<span class="token punctuation">;</span>
first <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
second <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
first<span class="token operator">++</span><span class="token punctuation">;</span>
second<span class="token operator">--</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二种删除</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三种删除元素8</span></code></pre>

<ul>
<li><font color=red>注意：set中的删除操作是不进行任何的错误检查的，比如定位器的是否合法等等</font></li>
</ul>
<h3 id="五、基本操作函数"><a href="#五、基本操作函数" class="headerlink" title="五、基本操作函数"></a>五、基本操作函数</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指向第一个元素的迭代器</span>
s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指向最后一个元素的迭代器</span>
s<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指向集合中最后一个元素的反向迭代器</span>
s<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指向集合中第一个元素的反向迭代器</span>
s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除所有元素</span>
s<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回某个值元素的个数(在set中并不实用，只能返回0或1，判断某元素是否出现)</span>
s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果集合为空，返回true</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在集合中插入元素</span>
s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个指向被查找到元素的迭代器</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除集合中的元素</span>
s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 集合中元素的数目</span>
s<span class="token punctuation">.</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回集合能容纳的元素的最大限值</span>
s<span class="token punctuation">,</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>key_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回第一个大于等于key_value的定位器</span>
s<span class="token punctuation">.</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>key_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回最后一个大于等于key_value的定位器</span>
s<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回集合中与给定值相等的上下限的两个迭代器</span>
s<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 交换两个集合变量</span></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2020/05/21/STL%EF%BC%9Aset%E7%94%A8%E6%B3%95/" data-id="ckmm2kgkt0015649v7kljc5xp" data-title="STL：set用法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-STL：list用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/20/STL%EF%BC%9Alist%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-05-19T16:00:00.000Z" itemprop="datePublished">2020-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/STL%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/">STL常用模板总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/20/STL%EF%BC%9Alist%E7%94%A8%E6%B3%95/">STL：list用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><font size=4 color=blue>        List是STL实现的双向链表，元素按顺序储存在链表中，与向量(vector)相比，它允许快速的插入和删除，但是随机访问却比较慢。</font></p>
</blockquote>
<ul>
<li><font size=4 color=red>使用时包含头文件：<code>#include&lt;list&gt;</code></font></li>
</ul>
<h3 id="一、list的创建"><a href="#一、list的创建" class="headerlink" title="一、list的创建"></a>一、list的创建</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l1<span class="token punctuation">;</span> <span class="token comment">// 创建空list</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">l2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建含有5个元素(其默认值为0)的list</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">l3</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建含有3个元素(其值均为2)的list</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">l4</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用l2初始化l4</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">l5</span><span class="token punctuation">(</span>l2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同l4</span></code></pre>

<h3 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//list&lt;int> Lst;</span>
Lst1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在list的末尾添加一个元素5</span>
Lst1<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在list的头部添加一个元素6</span>
Lst1<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除最后一个元素 </span>
Lst1<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除第一个元素 </span>
Lst1<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回最后一个元素 </span>
Lst1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回第一个元素</span>
Lst1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指向第一个元素的迭代器 </span>
Lst1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回末尾的迭代器</span>
Lst1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果list是空的则返回true </span>
Lst1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回list中的元素个数 </span>
Lst1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除所有元素 </span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
Lst1<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 给list赋值 </span>
Lst1<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除一个元素 </span>
Lst1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 插入一个元素到list中 </span>
Lst1<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 给list排序 </span>
Lst1<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把list的元素倒转 </span></code></pre>

<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2020/05/20/STL%EF%BC%9Alist%E7%94%A8%E6%B3%95/" data-id="ckmm2kgkm000s649vavx838en" data-title="STL：list用法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-STL：pair、tuple用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/16/STL%EF%BC%9Apair%E3%80%81tuple%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-05-15T16:00:00.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/STL%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/">STL常用模板总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/16/STL%EF%BC%9Apair%E3%80%81tuple%E7%94%A8%E6%B3%95/">STL：pair、tuple用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><font color=blue>        pair即“一对”的意思，将两个任意的数据类型绑定为一个整体，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。</font></p>
</blockquote>
<ul>
<li><font size=4 color=red>使用时包含头文件<code>#include&lt;utility&gt;</code></font></li>
</ul>
<h3 id="一、pair的创建"><a href="#一、pair的创建" class="headerlink" title="一、pair的创建"></a>一、pair的创建</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//可直接声明</span>
pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> p1<span class="token punctuation">;</span>
pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"something"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化</span>
pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span> p3<span class="token punctuation">;</span>
pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> p4<span class="token punctuation">;</span>
pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> p5 <span class="token operator">=</span> p4<span class="token punctuation">;</span> <span class="token comment">// 拷贝构造</span>
pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> p6<span class="token punctuation">;</span>
<span class="token comment">//可使用所提供的创建函数make_pair()</span>
pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> p<span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
px <span class="token operator">=</span> make_pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h3 id="二、pair的访问操作"><a href="#二、pair的访问操作" class="headerlink" title="二、pair的访问操作"></a>二、pair的访问操作</h3><ul>
<li>对于pair类，可以直接访问其数据成员：其成员都是公有的，分别命名为first和second，只需要使用普通的点操作符即可。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">if(p.first &#x3D;&#x3D; 3 &amp;&amp; p.second &#x3D;&#x3D; &quot;hello&quot;)&#123;&#x2F;* do something *&#x2F;&#125;</code></pre>



<blockquote>
<p><font color=blue>        tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。</font></p>
</blockquote>
<ul>
<li><font color=red>使用时包含头文件<code>#include&lt;utility&gt;</code></font></li>
</ul>
<h3 id="三、tuple的创建"><a href="#三、tuple的创建" class="headerlink" title="三、tuple的创建"></a>三、tuple的创建</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> string<span class="token operator">></span> t<span class="token punctuation">;</span> <span class="token comment">// 创建一个空的tuple对象（使用默认构造）</span>
tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> string<span class="token operator">></span> <span class="token function">t2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>

<h3 id="四、tuple的访问操作"><a href="#四、tuple的访问操作" class="headerlink" title="四、tuple的访问操作"></a>四、tuple的访问操作</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// tuple&lt;int, double, string> t;</span>
get<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问t中的double值，以此类推</span></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2020/05/16/STL%EF%BC%9Apair%E3%80%81tuple%E7%94%A8%E6%B3%95/" data-id="ckmm2kgkp000y649v09j810yh" data-title="STL：pair、tuple用法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-STL：queue用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/15/STL%EF%BC%9Aqueue%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-05-14T16:00:00.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/STL%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/">STL常用模板总结</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/15/STL%EF%BC%9Aqueue%E7%94%A8%E6%B3%95/">STL：queue用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><font size=4 color=blue>        与stack 模板类很相似，queue 模板类也需要两个模板参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为deque 类型。</font></p>
</blockquote>
<h3 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h3><ul>
<li>包含头文件<code>#include&lt;queue&gt;</code></li>
</ul>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span> <span class="token comment">// 创建队列</span>
q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 入队</span>
q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出队，无返回值，若队空则报错</span>
q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问队头</span>
q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问队尾</span>
q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断是否为空</span>
q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回元素个数</span></code></pre>

<h3 id="个人实现的简单版本"><a href="#个人实现的简单版本" class="headerlink" title="个人实现的简单版本"></a>个人实现的简单版本</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//队列模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">// 链表队列</span>
<span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
		<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
		<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			s<span class="token operator">++</span><span class="token punctuation">;</span>
			list<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">list</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>ptop <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				ptop <span class="token operator">=</span> p<span class="token punctuation">;</span>
				prear <span class="token operator">=</span> p<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span><span class="token punctuation">&#123;</span>
				prear<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
				prear <span class="token operator">=</span> p<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
		<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
			s<span class="token operator">--</span><span class="token punctuation">;</span>
			list<span class="token operator">*</span> p <span class="token operator">=</span> ptop<span class="token operator">-></span>next<span class="token punctuation">;</span>
			<span class="token keyword">delete</span><span class="token punctuation">(</span>ptop<span class="token punctuation">)</span><span class="token punctuation">;</span>
			ptop <span class="token operator">=</span> p<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		T <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>ptop <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> ptop<span class="token operator">-></span>data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
			<span class="token comment">//else return NULL;</span>
		<span class="token punctuation">&#125;</span>
		T <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> prear<span class="token operator">-></span>data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
			<span class="token comment">//else return NULL;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			ptop <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
			prear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">class</span> <span class="token class-name">list</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">public</span><span class="token operator">:</span>
				<span class="token function">list</span><span class="token punctuation">(</span>T data<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
				T data<span class="token punctuation">;</span>
				list<span class="token operator">*</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		list<span class="token operator">*</span> ptop<span class="token punctuation">;</span>
		list<span class="token operator">*</span> prear<span class="token punctuation">;</span>
		<span class="token keyword">int</span> s<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token comment">// 顺序队列</span>
<span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T ev<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
			num<span class="token operator">++</span><span class="token punctuation">;</span>
			data<span class="token punctuation">[</span>end<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ev<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>end <span class="token operator">==</span> <span class="token number">2000</span><span class="token punctuation">)</span> end <span class="token operator">-=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
		<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
			num<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>start <span class="token operator">==</span> <span class="token number">2000</span><span class="token punctuation">)</span> start <span class="token operator">-=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		T <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token keyword">return</span> data<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
		T <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> t <span class="token operator">=</span> end <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">?</span> end <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">:</span> end <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2000</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> data<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
		<span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
		<span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		T data<span class="token punctuation">[</span><span class="token number">2000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> start<span class="token punctuation">;</span>
		<span class="token keyword">int</span> end<span class="token punctuation">;</span>
		<span class="token keyword">int</span> num<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h3 id="二、优先队列：priority-queue"><a href="#二、优先队列：priority-queue" class="headerlink" title="二、优先队列：priority_queue"></a><font color=red>二、优先队列：<strong>priority_queue</strong></font></h3><blockquote>
<p><font color=blue>        在&lt;queue&gt;头文件中，还定义了另一个非常有用的模板类<strong>priority_queue（优先队列）</strong>。优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。</font></p>
<p><font color=blue>        priority_queue 模板类有3个模板参数：priority_queue&lt;Type, Container, Functional&gt;，其中Type 为数据类型，Container为保存数据的容器类型，Functional 为元素比较方式（即比较算子）。其中后两个都可以省略，默认容器为vector，默认算子为less，即从小到大排列。</font></p>
</blockquote>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//优先队列的声明</span>
priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q1<span class="token punctuation">;</span>
priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> q2<span class="token punctuation">;</span> <span class="token comment">// 定义小的先出队</span></code></pre>

<ul>
<li><p>操作与queue基本一致。</p>
</li>
<li><p>若使用自定义类型，则需要重载运算符，以满足排列比较要求。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jq-mono.github.io/2020/05/15/STL%EF%BC%9Aqueue%E7%94%A8%E6%B3%95/" data-id="ckmm2kgkr0012649v8ojs05jb" data-title="STL：queue用法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/" rel="tag">STL</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LC%E5%91%A8%E8%B5%9B/">LC周赛</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/STL%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/">STL常用模板总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/">小技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AB%98%E7%B2%BE%E5%BA%A6/" rel="tag">字符串高精度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/STL/" style="font-size: 20px;">STL</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%AB%98%E7%B2%BE%E5%BA%A6/" style="font-size: 10px;">字符串高精度</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">小技巧</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/21/LeetCode%E7%AC%AC233%E5%9C%BA%E5%91%A8%E8%B5%9B/">LeetCode第233场周赛</a>
          </li>
        
          <li>
            <a href="/2021/03/14/LeetCode%E7%AC%AC232%E5%9C%BA%E5%91%A8%E8%B5%9B/">LeetCode第232场周赛</a>
          </li>
        
          <li>
            <a href="/2021/03/07/c++%E4%BD%8D%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0%E4%B9%8B-__builtin_/">c++位运算函数之（__builtin_）</a>
          </li>
        
          <li>
            <a href="/2021/03/06/LeetCode%E7%AC%AC47%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/">LeetCode第47场双周赛</a>
          </li>
        
          <li>
            <a href="/2021/02/28/LeetCode%E7%AC%AC230%E5%9C%BA%E5%91%A8%E8%B5%9B/">LeetCode第230场周赛</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>